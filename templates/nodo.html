<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Nodo {{ nodo_info.name }}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            padding: 2em;
        }

        .columna {
            background-color: white;
            padding: 1.5em;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            max-width: 100%;
        }

        h1, h2, h3 {
            color: #333;
        }

        table {
            margin-top: 1em;
            border-collapse: collapse;
            width: 100%;
            font-size: 0.9em;
        }

        th, td {
            padding: 0.6em;
            border: 1px solid #ccc;
            text-align: center;
        }

        th {
            background-color: #eeeeee;
        }

        #canvas {
            width: 100%;
            height: 400px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            cursor: grab;
        }

        .link {
            stroke: red;
            stroke-width: 2px;
        }

        .pgen-input,
        .name-input {
            position: absolute;
            display: none;
            z-index: 10;
        }

        .label {
            font-size: 12px;
            text-anchor: middle;
            pointer-events: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .node {
            cursor: pointer;
        }

        #tabla-nodos, #tabla-aristas {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1em;
            font-size: 0.9em;
        }

        #tabla-nodos th, #tabla-nodos td,
        #tabla-aristas th, #tabla-aristas td {
            border: 1px solid #ccc;
            padding: 0.4em;
            text-align: center;
        }

        #tabla-nodos input, #tabla-aristas input {
            width: 90%;
            padding: 0.2em;
            font-size: 0.9em;
        }

        .matrix-input {
            width: 40px;
            text-align: center;
            padding: 2px;
            margin: 1px;
        }

        #ordenesNodo {
            background-color: #f9f9f9;
            border: 1px solid #ccc;
            padding: 1em;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
<div class="container-flex">
    <div class="columna">
        <h2>
            Mapa del Nodo {{ nodo_info.name }}
            <button onclick="window.open('/info', '_blank')">Ver JSON del Nodo</button>
        </h2>
        <svg id="canvas"></svg>

        <h3>Información del Nodo</h3>
        <table id="tabla-nodo">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Nombre</th>
                    <th>Roles</th>
                    <th>pswap</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>{{ nodo_info.id }}</td>
                    <td><input type="text" id="nameInput" value="{{ nodo_info.name }}"></td>
                    <td>
                        {% for role in ["emisor","receptor","repeater"] %}
                            <label>
                                <input type="checkbox" class="roleChk" value="{{ role }}" {% if role in nodo_info.roles %}checked{% endif %}>{{ role }}
                            </label>
                        {% endfor %}
                    </td>
                    <td><input type="number" id="pswapInput" min="0" max="1" step="0.01" value="{{ nodo_info.get('pswap',0.0) }}"></td>
                </tr>
            </tbody>
        </table>

        <h3>Vecinos</h3>
        <table id="tabla-aristas">
            <thead>
                <tr><th>Source</th><th>Target</th><th>Distancia (km)</th><th>pgen</th></tr>
            </thead>
            <tbody>
                {% for vecino in nodo_info.get("neighbors", []) %}
                    {% if vecino %}
                    <tr>
                        <td>{{ nodo_info.id }}</td>
                        <td>{{ vecino.id }}</td>
                        <td><input type="number" class="distInput" value="{{ vecino.distanceKm }}"></td>
                        <td><input type="number" class="pgenInput" value="{{ vecino.pgen }}"></td>
                    </tr>
                    {% endif %}
                {% endfor %}
            </tbody>
        </table>

        <h3>Órdenes del Nodo</h3>
        <pre id="ordenesNodo">Cargando...</pre>
    </div>
</div>

<script>
window.onload = function () {
    const nodo = JSON.parse('{{ nodo_info|tojson|safe }}');
    const nodo_id = nodo.id;
    const svg = document.getElementById("canvas");
    const ns = "http://www.w3.org/2000/svg";

    function actualizarNodo() {
        fetch("/info")
            .then(res => res.json())
            .then(data => {
                console.log("Datos recibidos de /info:", data);
                // actualizar nodo global
                Object.assign(nodo, data);

                // actualizar inputs
                document.getElementById("nameInput").value = data.name;
                document.getElementById("pswapInput").value = data.pswap || 0;
                document.querySelectorAll(".roleChk").forEach(chk => {
                    chk.checked = data.roles.includes(chk.value);
                });

                // actualizar tabla vecinos
                const tbody = document.querySelector("#tabla-aristas tbody");
                tbody.innerHTML = "";
                data.neighbors.forEach((vecino, idx) => {
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td>${data.id}</td>
                        <td>${vecino.name || vecino.id}</td>
                        <td><input type="number" class="distInput" value="${vecino.distanceKm}"></td>
                        <td><input type="number" class="pgenInput" value="${vecino.pgen}"></td>
                    `;
                    tbody.appendChild(tr);

                    // seleccionar el input recién creado
                    const input = tr.querySelector(".distInput");

                    // enganchar eventos al input
                    input.addEventListener("focus", pausarActualizaciones);
                    input.addEventListener("blur", reanudarActualizaciones);
                    input.addEventListener("change", e => {
                        const nuevaDistancia = parseFloat(e.target.value);
                        nodo.neighbors[idx].distanceKm = new_Distance;
                        nodo.neighbors[idx].pgen = new_pgen;

                        const vecinoid = nodo.neighbors[idx].id;

                        // enviar actualización al backend
                        fetch("/update", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                source: nodo.id,
                                target: vecinoid,
                                distanciaKm: new_Distance,
                                pgen: new_pgen,
                                lastUpdated: Date.now()
                            })
                        });
                    });
                });

                drawMapa();
            })
            .catch(console.error);
    }




    // Actualizar nombre del nodo
    document.getElementById("nameInput").addEventListener("change", e => {
        fetch("/update", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name: e.target.value, lastUpdated: Date.now() })
        });
    });


    // Actualizar pswap
    document.getElementById("pswapInput").addEventListener("change", e => {
        fetch("/update", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ pswap: parseFloat(e.target.value), lastUpdated: Date.now() })
        });
    });

    // Actualizar roles
    document.querySelectorAll(".roleChk").forEach(chk => {
        chk.addEventListener("change", () => {
            const roles = Array.from(document.querySelectorAll(".roleChk"))
                .filter(c => c.checked)
                .map(c => c.value);
            fetch("/update", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ roles, lastUpdated: Date.now() })
            });
        });
    });

    // Preparar vecinos con posiciones iniciales
    const vecinos = nodo.neighbors.map((vecino, i) => {
        const angle = (2 * Math.PI * i) / nodo.neighbors.length;
        return {
            ...vecino,
            x: nodo.x + 100 * Math.cos(angle),
            y: nodo.y + 100 * Math.sin(angle)
        };
    });

    function drawMapa() {
        svg.innerHTML = "";

        // Recalcular posiciones de vecinos en cada redibujo
        const vecinos = nodo.neighbors.map((vecino, i) => {
            const angle = (2 * Math.PI * i) / nodo.neighbors.length;
            return {
                ...vecino,
                x: nodo.x + 100 * Math.cos(angle),
                y: nodo.y + 100 * Math.sin(angle)
            };
        });

        // Nodo central
        const centralCircle = document.createElementNS(ns, "circle");
        centralCircle.setAttribute("cx", nodo.x);
        centralCircle.setAttribute("cy", nodo.y);
        centralCircle.setAttribute("r", 20);
        centralCircle.setAttribute("fill", "lightblue");
        centralCircle.style.cursor = "grab";
        svg.appendChild(centralCircle);

        const centralLabel = document.createElementNS(ns, "text");
        centralLabel.setAttribute("x", nodo.x);
        centralLabel.setAttribute("y", nodo.y + 40);
        centralLabel.setAttribute("text-anchor", "middle");
        centralLabel.textContent = nodo.id;
        svg.appendChild(centralLabel);

        // Vecinos y enlaces
        vecinos.forEach((vecino, i) => {
            const line = document.createElementNS(ns, "line");
            line.setAttribute("x1", nodo.x);
            line.setAttribute("y1", nodo.y);
            line.setAttribute("x2", vecino.x);
            line.setAttribute("y2", vecino.y);
            line.setAttribute("stroke", "#999");
            line.setAttribute("stroke-width", "2");
            svg.appendChild(line);

            const vCircle = document.createElementNS(ns, "circle");
            vCircle.setAttribute("cx", vecino.x);
            vCircle.setAttribute("cy", vecino.y);
            vCircle.setAttribute("r", 15);
            vCircle.setAttribute("fill", "orange");
            vCircle.style.cursor = "grab";
            svg.appendChild(vCircle);

            const vLabel = document.createElementNS(ns, "text");
            vLabel.setAttribute("x", vecino.x);
            vLabel.setAttribute("y", vecino.y + 25);
            vLabel.setAttribute("text-anchor", "middle");
            vLabel.textContent = vecino.id;
            svg.appendChild(vLabel);
        });

        // Arrastrar nodo central
        let draggingCentral = false;
        let offsetX = 0, offsetY = 0;

        centralCircle.addEventListener("mousedown", e => {
            draggingCentral = true;
            offsetX = e.offsetX - nodo.x;
            offsetY = e.offsetY - nodo.y;
        });

        svg.addEventListener("mousemove", e => {
            if (draggingCentral) {
                nodo.x = e.offsetX - offsetX;
                nodo.y = e.offsetY - offsetY;
                drawMapa(); // redibuja con nuevas posiciones
            }
        });

        svg.addEventListener("mouseup", () => draggingCentral = false);
        svg.addEventListener("mouseleave", () => draggingCentral = false);

        // Arrastrar vecinos
        const circles = svg.querySelectorAll("circle");
        const labels = svg.querySelectorAll("text");
        const lines = svg.querySelectorAll("line");

        vecinos.forEach((vecino, i) => {
            let isDragging = false;
            let offsetX, offsetY;
            const circle = circles[i + 1];
            const label = labels[i + 1];
            const line = lines[i];

            circle.addEventListener("mousedown", e => {
                isDragging = true;
                offsetX = e.offsetX - vecino.x;
                offsetY = e.offsetY - vecino.y;
            });

            svg.addEventListener("mousemove", e => {
                if (!isDragging) return;
                vecino.x = e.offsetX - offsetX;
                vecino.y = e.offsetY - offsetY;
                circle.setAttribute("cx", vecino.x);
                circle.setAttribute("cy", vecino.y);
                label.setAttribute("x", vecino.x);
                label.setAttribute("y", vecino.y + 25);
                line.setAttribute("x2", vecino.x);
                line.setAttribute("y2", vecino.y);
            });

            svg.addEventListener("mouseup", () => isDragging = false);
            svg.addEventListener("mouseleave", () => isDragging = false);
        });
    }


    drawMapa();

    const preOrdenes = document.getElementById("ordenesNodo");
    let ultimasOrdenes = [];  // cache local de las últimas órdenes

    function actualizarOrdenes() {
        fetch("/orders")
            .then(res => res.json())
            .then(data => {
                if (!data || data.length === 0) {
                    preOrdenes.textContent = "No hay órdenes aún.";
                    return;
                }

                // Mostrar las órdenes
                preOrdenes.textContent = data
                    .map((o, i) => `${i + 1}. ${JSON.stringify(o)}`)
                    .join("\n");

                // Comparar con las últimas
                const nuevasOrdenes = JSON.stringify(data);
                const anterioresOrdenes = JSON.stringify(ultimasOrdenes);

                if (nuevasOrdenes !== anterioresOrdenes) {
                    console.log("Órdenes nuevas detectadas, aplicando...");
                    console.log("Tiene un sleep de 500 ms");
                    data.forEach((orden, idx) => {
                        setTimeout(() => {
                            fetch("/operations", {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify(orden)
                            }).catch(err => console.error("Error aplicando orden:", err));
                        }, idx * 500); // ⏱ cada orden se retrasa 0.2s respecto a la anterior
                    });
                    ultimasOrdenes = data;
                } else {
                    console.log("Órdenes iguales, no se reenvían");
                }
            })
            .catch(err => {
                console.error("Error al obtener órdenes:", err);
                preOrdenes.textContent = "Error al obtener órdenes.";
            });
    }


    const evtSource = new EventSource("/mandate/stream");
    evtSource.onmessage = function(event) {
        if (event.data === "mandate") {
            console.log("Mandato detectado, refrescando órdenes...");
            actualizarOrdenes();
        }
    };


    // Llamada inicial
    actualizarOrdenes();
    actualizarNodo();

    // Guardar los IDs de los intervalos
    let nodoInterval = setInterval(actualizarNodo, 2000);
   // let ordenesInterval = setInterval(actualizarOrdenes, 2000);

    // Funciones para pausar y reanudar
    function pausarActualizaciones() {
        clearInterval(nodoInterval);
       // clearInterval(ordenesInterval);
        console.log("Actualizaciones pausadas");
    }

    function reanudarActualizaciones() {
        nodoInterval = setInterval(actualizarNodo, 2000);
       // ordenesInterval = setInterval(actualizarOrdenes, 2000);
        console.log("Actualizaciones reanudadas");
    }

    // Detectar cuando el usuario escribe en un input
    document.querySelectorAll("input, textarea").forEach(el => {
        el.addEventListener("focus", pausarActualizaciones);
        el.addEventListener("blur", reanudarActualizaciones);
    });


    };
</script>
</body>
</html>
