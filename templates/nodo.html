<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Node {{ node_info.name }}</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            padding: 2em;
        }

        .columna {
            background-color: white;
            padding: 1.5em;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            max-width: 100%;
        }

        h1, h2, h3 {
            color: #333;
        }

        table {
            margin-top: 1em;
            border-collapse: collapse;
            width: 100%;
            font-size: 0.9em;
        }

        th, td {
            padding: 0.6em;
            border: 1px solid #ccc;
            text-align: center;
        }

        th {
            background-color: #eeeeee;
        }

        #map-wrapper {
            position: relative;
            height: 600px;
        }
        #map {
            width: 100%;
            height: 100%;
        }
        svg {
            overflow: visible;
        }

        .link {
            stroke: red;
            stroke-width: 2px;
        }

        .label {
            font-size: 12px;
            text-anchor: middle;
            pointer-events: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .node {
            cursor: pointer;
        }
        /* Estilo general del checkbox */
        /* Reset completo solo para el checkbox */
        #tabla-node .roleChk {
            all: unset;          /* borra TODO el estilo heredado */
            appearance: auto;    /* vuelve a ser un checkbox normal */
            cursor: pointer;
        }




        #tabla-node, #tabla-aristas {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1em;
            font-size: 0.9em;
        }

        #tabla-node th, #tabla-node td,
        #tabla-aristas th, #tabla-aristas td {
            border: 1px solid #ccc;
            padding: 0.4em;
            text-align: center;
        }

        #tabla-node input, #tabla-aristas input {
            width: 90%;
            padding: 0.2em;
            font-size: 0.9em;
        }

        .matrix-input {
            width: 40px;
            text-align: center;
            padding: 2px;
            margin: 1px;
        }

        #ordenesNodo {
            background-color: #f9f9f9;
            border: 1px solid #ccc;
            padding: 1em;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        /* === Night mode for this section === */
        /* Fondo general */
        body.night {
            background-color: #1e1e1e;
            color: #eee;
        }

        /* Columna principal */
        body.night .columna {
            background-color: #2a2a2a;
            color: #eee;
            box-shadow: 0 0 10px rgba(255,255,255,0.05);
        }

        /* T√≠tulos */
        body.night h1,
        body.night h2,
        body.night h3 {
            color: #ddd;
        }

        /* Tablas */
        body.night table th {
            background-color: #333;
            color: #eee;
        }
        body.night table td {
            background-color: #2a2a2a;
            color: #eee;
            border-color: #555;
        }

        /* Etiquetas */
        body.night .label {
            color: #ccc;
        }

        /* Tabla nodes y aristas */
        body.night #tabla-node th,
        body.night #tabla-aristas th {
            background-color: #333;
            color: #eee;
        }
        body.night #tabla-node td,
        body.night #tabla-aristas td {
            background-color: #2a2a2a;
            color: #eee;
            border-color: #555;
        }

        /* Inputs de tabla */
        body.night #tabla-node input,
        body.night #tabla-aristas input {
            background-color: #444;
            color: #eee;
            border: 1px solid #666;
        }
        body.night #tabla-node .roleChk {
            accent-color: #bb86fc; /* morado suave estilo Material Night */
            filter: brightness(0.8);
        }


        /* Matrices */
        body.night .matrix-input {
            background-color: #444;
            color: #eee;
            border: 1px solid #666;
        }

        /* Panel de √≥rdenes */
        body.night #ordenesNodo {
            background-color: #2a2a2a;
            border-color: #555;
            color: #eee;
        }
        /* Buttons in night mode */
        body.night .button {
            background-color: #555;
            color: #eee;
        }

    </style>
</head>
<body>
<div class="container-flex">
    <div class="columna">
        <h2>
            Node map {{ node_info.name }}
            <button class="button"o nclick="window.open('/info', '_blank')">Watch JSON of the node</button>
            <button id="resetView" class="button">üìç</button>
            <!-- Interactive icon for day/night -->
            <span id="toggleIcon">üåû</span>
        </h2>
        <div id="map-wrapper">
            <div id="map"></div>
        </div>

        <!-- Leaflet JS -->
        <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
        <!-- D3.js -->
        <script src="https://d3js.org/d3.v7.min.js"></script>

        <h3>Nodo Info</h3>
        <table id="tabla-node">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Name</th>
                    <th>Role</th>
                    <th>Pswap</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>{{ node_info.id }}</td>
                    <td><input type="text" id="nameInput" value="{{ node_info.name }}"></td>
                    <td>
                        {% for role in ["emisor","receptor","repeater"] %}
                            <label>
                                <input type="checkbox" class="roleChk" value="{{ role }}" {% if role in node_info.roles %}checked{% endif %}>{{ role }}
                            </label>
                        {% endfor %}
                    </td>
                    <td><input type="number" id="pswapInput" min="0" max="1" step="0.01" value="{{ node_info.get('pswap',0.0) }}"></td>
                </tr>
            </tbody>
        </table>

        <h3>Links</h3>
        <table id="tabla-aristas">
            <thead>
                <tr><th>Source</th><th>Target</th><th>Distance (km)</th><th>Pgen</th></tr>
            </thead>
            <tbody>
                {% for vecino in node_info.get("neighbors", []) %}
                    {% if vecino %}
                    <tr data-id="{{ vecino.id }}">
                        <td>{{ node_info.id }}</td>
                        <td>{{ vecino.id }}</td>
                        <td><input type="number" class="distInput" step="0.1" value="{{ vecino.distanceKm }}"></td>
                        <td><input type="number" class="pgenInput" min="0" max="1" step="0.01" value="{{ vecino.pgen }}"></td>
                    </tr>
                    {% endif %}
                {% endfor %}
            </tbody>
        </table>

        <h3>√ìrdenes del Nodo</h3>
        <pre id="ordenesNodo">Cargando...</pre>
    </div>
</div>

<script>
    // Day/Night toggle
    const icon = document.getElementById("toggleIcon");
    const body = document.body;
    icon.addEventListener("click", () => {
        body.classList.toggle("day");
        body.classList.toggle("night");
        icon.textContent = body.classList.contains("day") ? "üåû" : "üåô";
    });
    window.onload = function () {
        // Parse node_info from backend
        const node = JSON.parse('{{ node_info|tojson|safe }}');
        const resetViewBtn = document.getElementById("resetView");

        // Inicializar mapa Leaflet
        const map = L.map('map').setView([node.lat, node.lon], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        // A√±adir capa SVG para D3
        const svgLayer = L.svg().addTo(map);
        const svg = d3.select("#map").select("svg");

        resetViewBtn.onclick = () => {
                map.setView([node.lat, node.lon], 13);
            };

        // Arrays globales de nodes y enlaces
        let nodes = [node];
        let links = [];

        // Si el node tiene vecinos, a√±adirlos como nodes y enlaces
        node.neighbors.forEach((vecino, i) => {
            // Si no tiene lat/lon, asignar aleatorio alrededor
            if (!vecino.lat || !vecino.lon) {
                const radius = 0.01; // ~1 km
                let angle;
                if (node.neighbors.length === 2) {
                    angle = i === 0 ? 0 : Math.PI;
                } else {
                    angle = Math.random() * 2 * Math.PI;
                }
                vecino.lat = node.lat + radius * Math.cos(angle);
                vecino.lon = node.lon + radius * Math.sin(angle);
            }
            nodes.push(vecino);
            links.push({ source: node.id, target: vecino.id });
        });

        let draggingNode = null;
        let linkStart = null;

        // -------------------- DRAW FUNCTION --------------------
        function draw() {
            svg.selectAll("*").remove();

            // Dibujar enlaces
            links.forEach(link => {
                const sourceNode = nodes.find(n => n.id === link.source);
                const targetNode = nodes.find(n => n.id === link.target);
                if (!sourceNode || !targetNode) return;

                const sourcePoint = map.latLngToLayerPoint([sourceNode.lat, sourceNode.lon]);
                const targetPoint = map.latLngToLayerPoint([targetNode.lat, targetNode.lon]);

                svg.append("line")
                    .attr("x1", sourcePoint.x)
                    .attr("y1", sourcePoint.y)
                    .attr("x2", targetPoint.x)
                    .attr("y2", targetPoint.y)
                    .attr("stroke", "#0b3c7a")
                    .attr("stroke-width", 3)
                    .attr("opacity", 0.9);
            });

            // Dibujar nodes
            nodes.forEach(node => {
                const point = map.latLngToLayerPoint([node.lat, node.lon]);

                // C√≠rculo
                svg.append("circle")
                    .attr("cx", point.x)
                    .attr("cy", point.y)
                    .attr("r", 14)
                    .attr("fill", "#054eb5")
                    .attr("opacity", 0.85);

                // Etiqueta
                svg.append("text")
                    .attr("x", point.x)
                    .attr("y", point.y - 15)
                    .attr("text-anchor", "middle")
                    .text(node.name || node.id)
                    .attr("fill", "black");
            });
        }

        // -------------------- MAP EVENTS --------------------

        map.on("mousemove", e => {
            if (draggingNode) {
                draggingNode.lat = e.latlng.lat;
                draggingNode.lon = e.latlng.lng;
                draw();
            }
        });

        map.on("mouseup", () => {
            draggingNode = null;
        });

        map.on("zoom move", draw);


        // Primer dibujo
        draw();
        let lastInfo = [];  // Local cache of the last info of the node
        function actualizarNodo() {
            fetch("/info")
                .then(res => res.json())
                .then(data => {
                    console.log("Datos recibidos de /info:", data);
                    // Comparar con las √∫ltimas
                    const info = JSON.stringify(data);
                    const otherInfo = JSON.stringify(lastInfo);
                    if(info != otherInfo){
                        Object.assign(node, data);
                        // Update nodes and links for the map overlay
                        nodes = [node]; // main node
                        links = [];

                        data.neighbors.forEach(vecino => {
                            // Assign temporary coordinates if missing
                            if (!vecino.lat || !vecino.lon) {
                                const radius = 0.01;
                                const angle = Math.random() * 2 * Math.PI;
                                vecino.lat = node.lat + radius * Math.cos(angle);
                                vecino.lon = node.lon + radius * Math.sin(angle);
                            }

                            nodes.push(vecino);
                            links.push({ source: node.id, target: vecino.id });
                        });


                        // preserve client-side coordinates
                        if (draggingNode) {
                            node.lat = draggingNode.lat;
                            node.lon = draggingNode.lon;
                        }

                        // Node inputs
                        document.getElementById("nameInput").value = data.name;
                        document.getElementById("pswapInput").value = data.pswap || 0;
                        document.querySelectorAll(".roleChk").forEach(chk => {
                            chk.checked = data.roles.includes(chk.value);
                        });

                        // Attach node listeners
                        document.getElementById("nameInput").onchange = e =>
                            updateEntity({ type: "node", field: "name", value: e.target.value });

                        document.getElementById("pswapInput").onchange = e =>
                            updateEntity({ type: "node", field: "pswap", value: parseFloat(e.target.value) });

                        document.querySelectorAll(".roleChk").forEach(chk => {
                            chk.onchange = () => {
                                const roles = Array.from(document.querySelectorAll(".roleChk"))
                                    .filter(c => c.checked)
                                    .map(c => c.value);
                                updateEntity({ type: "node", field: "roles", value: roles });
                            };
                        });

                        // Neighbor table
                        const tbody = document.querySelector("#tabla-aristas tbody");

                        // Keep existing rows if they exist, otherwise create new ones
                        data.neighbors.forEach(vecino => {
                            // Look for an existing row by vecino.id
                            let tr = tbody.querySelector(`tr[data-id='${vecino.id}']`);
                            if (!tr) {
                                // Create a new row
                                tr = document.createElement("tr");
                                tr.dataset.id = vecino.id; // key to identify later
                                tr.innerHTML = `
                                    <td>${data.id}</td>
                                    <td>${vecino.name || vecino.id}</td>
                                    <td><input type="number" class="distInput" step="0.1"></td>
                                    <td><input type="number" class="pgenInput" min="0" max="1" step="0.01"></td>
                                `;
                                tbody.appendChild(tr);

                                const distInput = tr.querySelector(".distInput");
                                const pgenInput = tr.querySelector(".pgenInput");

                                // Attach handlers directly to the inputs
                                distInput.onchange = () =>
                                    updateEntity({ type: "neighbor", field: "distanceKm", value: parseFloat(distInput.value), neighborId: vecino.id });

                                pgenInput.onchange = () =>
                                    updateEntity({ type: "neighbor", field: "pgen", value: parseFloat(pgenInput.value), neighborId: vecino.id });
                            }

                            // Update input values only if the user is not focused on them
                            const distInput = tr.querySelector(".distInput");
                            const pgenInput = tr.querySelector(".pgenInput");
                            if (document.activeElement !== distInput) distInput.value = vecino.distanceKm;
                            if (document.activeElement !== pgenInput) pgenInput.value = vecino.pgen;
                        });


                        // Finally, redraw nodes and safely update lastInfo
                        draw();
                        lastInfo = JSON.parse(JSON.stringify(data));

                    }
                })
                .catch(console.error);
        }



        function updateEntity({ type, field, value, neighborId = null }) {
            // Pause polling immediately
            pausarActualizaciones();

            const payload = {
                lastUpdated: Date.now()
            };

            if (type === "node") {
                payload[field] = value;
            }

            if (type === "neighbor") {
                console.log("Cambiando distancia2");
                payload.source = node.id;
                payload.target = neighborId;
                payload[field] = value;
                console.log("Payload",payload);
            }

            return fetch("/update", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload)
            })
            .catch(err => console.error("Update error:", err))
            .finally(() => {
                // Resume polling after update finishes
                reanudarActualizaciones();
            });
        }

        const preOrdenes = document.getElementById("ordenesNodo");
        let ultimasOrdenes = [];  // cache local de las √∫ltimas √≥rdenes

        function actualizarOrdenes() {
            fetch("/orders")
                .then(res => res.json())
                .then(data => {
                    if (!data || data.length === 0) {
                        preOrdenes.textContent = "No hay √≥rdenes a√∫n.";
                        return;
                    }

                    // Mostrar las √≥rdenes
                    preOrdenes.textContent = data
                        .map((o, i) => `${i + 1}. ${JSON.stringify(o)}`)
                        .join("\n");

                    // Comparar con las √∫ltimas
                    const nuevasOrdenes = JSON.stringify(data);
                    const anterioresOrdenes = JSON.stringify(ultimasOrdenes);

                    if (nuevasOrdenes !== anterioresOrdenes) {
                        console.log("√ìrdenes nuevas detectadas, aplicando...");
                        console.log("Tiene un sleep de 500 ms");
                        data.forEach((orden, idx) => {
                            setTimeout(() => {
                                fetch("/operations", {
                                    method: "POST",
                                    headers: { "Content-Type": "application/json" },
                                    body: JSON.stringify(orden)
                                }).catch(err => console.error("Error aplicando orden:", err));
                            }, idx * 500); // ‚è± cada orden se retrasa 0.2s respecto a la anterior
                        });
                        ultimasOrdenes = data;
                    } else {
                        console.log("√ìrdenes iguales, no se reenv√≠an");
                    }
                })
                .catch(err => {
                    console.error("Error al obtener √≥rdenes:", err);
                    preOrdenes.textContent = "Error al obtener √≥rdenes.";
                });
        }


        const evtSource = new EventSource("/updates/stream");
        evtSource.onmessage = function(event) {
            if (event.data === "mandate") {
                console.log("Mandato detectado, refrescando √≥rdenes...");
                actualizarOrdenes();
            }
            else if(event.data === "update"){
                console.log("Updates detected, changing info...");
                actualizarNodo();
                draw();
                
            }
        };



        // Llamada inicial
        actualizarOrdenes();
        actualizarNodo();

        // Guardar los IDs de los intervalos
        let nodeInterval = setInterval(actualizarNodo, 2000);

        // Funciones para pausar y reanudar
        function pausarActualizaciones() {
            clearInterval(nodeInterval);
        // clearInterval(ordenesInterval);
            console.log("Actualizaciones pausadas");
        }

        function reanudarActualizaciones() {
            nodeInterval = setInterval(actualizarNodo, 2000);
        // ordenesInterval = setInterval(actualizarOrdenes, 2000);
            console.log("Actualizaciones reanudadas");
        }

        // Detectar cuando el usuario escribe en un input
        document.querySelectorAll("input, textarea").forEach(el => {
            el.addEventListener("focus", pausarActualizaciones);
            el.addEventListener("blur", reanudarActualizaciones);
        });
    };

</script>
</body>
</html>
