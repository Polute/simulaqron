<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Nodo {{ nodo_info.name }}</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            padding: 2em;
        }

        .columna {
            background-color: white;
            padding: 1.5em;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            max-width: 100%;
        }

        h1, h2, h3 {
            color: #333;
        }

        table {
            margin-top: 1em;
            border-collapse: collapse;
            width: 100%;
            font-size: 0.9em;
        }

        th, td {
            padding: 0.6em;
            border: 1px solid #ccc;
            text-align: center;
        }

        th {
            background-color: #eeeeee;
        }

        #map-wrapper {
            position: relative;
            height: 600px;
        }
        #map {
            width: 100%;
            height: 100%;
        }
        svg {
            overflow: visible;
        }

        .link {
            stroke: red;
            stroke-width: 2px;
        }

        .pgen-input,
        .name-input {
            position: absolute;
            display: none;
            z-index: 10;
        }

        .label {
            font-size: 12px;
            text-anchor: middle;
            pointer-events: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .node {
            cursor: pointer;
        }

        #tabla-nodos, #tabla-aristas {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1em;
            font-size: 0.9em;
        }

        #tabla-nodos th, #tabla-nodos td,
        #tabla-aristas th, #tabla-aristas td {
            border: 1px solid #ccc;
            padding: 0.4em;
            text-align: center;
        }

        #tabla-nodos input, #tabla-aristas input {
            width: 90%;
            padding: 0.2em;
            font-size: 0.9em;
        }

        .matrix-input {
            width: 40px;
            text-align: center;
            padding: 2px;
            margin: 1px;
        }

        #ordenesNodo {
            background-color: #f9f9f9;
            border: 1px solid #ccc;
            padding: 1em;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
<div class="container-flex">
    <div class="columna">
        <h2>
            Mapa del Nodo {{ nodo_info.name }}
            <button onclick="window.open('/info', '_blank')">Ver JSON del Nodo</button>
        </h2>
        <div id="map-wrapper">
            <div id="map"></div>
        </div>

        <!-- Leaflet JS -->
        <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
        <!-- D3.js -->
        <script src="https://d3js.org/d3.v7.min.js"></script>

        <h3>Nodo Info</h3>
        <table id="tabla-nodo">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Name</th>
                    <th>Role</th>
                    <th>Pswap</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>{{ nodo_info.id }}</td>
                    <td><input type="text" id="nameInput" value="{{ nodo_info.name }}"></td>
                    <td>
                        {% for role in ["emisor","receptor","repeater"] %}
                            <label>
                                <input type="checkbox" class="roleChk" value="{{ role }}" {% if role in nodo_info.roles %}checked{% endif %}>{{ role }}
                            </label>
                        {% endfor %}
                    </td>
                    <td><input type="number" id="pswapInput" min="0" max="1" step="0.01" value="{{ nodo_info.get('pswap',0.0) }}"></td>
                </tr>
            </tbody>
        </table>

        <h3>Links</h3>
        <table id="tabla-aristas">
            <thead>
                <tr><th>Source</th><th>Target</th><th>Distance (km)</th><th>Pgen</th></tr>
            </thead>
            <tbody>
                {% for vecino in nodo_info.get("neighbors", []) %}
                    {% if vecino %}
                    <tr>
                        <td>{{ nodo_info.id }}</td>
                        <td>{{ vecino.id }}</td>
                        <td><input type="number" class="distInput" step="0.1" value="{{ vecino.distanceKm }}"></td>
                        <td><input type="number" class="pgenInput" min="0" max="1" step="0.01" value="{{ vecino.pgen }}"></td>
                    </tr>
                    {% endif %}
                {% endfor %}
            </tbody>
        </table>

        <h3>Órdenes del Nodo</h3>
        <pre id="ordenesNodo">Cargando...</pre>
    </div>
</div>

<script>
    window.onload = function () {
        // Parse nodo_info from backend
        const nodo = JSON.parse('{{ nodo_info|tojson|safe }}');

        // Inicializar mapa Leaflet
        const map = L.map('map').setView([nodo.lat, nodo.lon], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        // Añadir capa SVG para D3
        const svgLayer = L.svg().addTo(map);
        const svg = d3.select("#map").select("svg");

        // Arrays globales de nodos y enlaces
        let nodes = [nodo];
        let links = [];

        // Si el nodo tiene vecinos, añadirlos como nodos y enlaces
        nodo.neighbors.forEach((vecino, i) => {
            // Si no tiene lat/lon, asignar aleatorio alrededor
            if (!vecino.lat || !vecino.lon) {
                const radius = 0.01; // ~1 km
                let angle;
                if (nodo.neighbors.length === 2) {
                    angle = i === 0 ? 0 : Math.PI;
                } else {
                    angle = Math.random() * 2 * Math.PI;
                }
                vecino.lat = nodo.lat + radius * Math.cos(angle);
                vecino.lon = nodo.lon + radius * Math.sin(angle);
            }
            nodes.push(vecino);
            links.push({ source: nodo.id, target: vecino.id });
        });

        let draggingNode = null;
        let linkStart = null;

        // -------------------- DRAW FUNCTION --------------------
        function draw() {
            svg.selectAll("*").remove();

            // Dibujar enlaces
            links.forEach(link => {
                const sourceNode = nodes.find(n => n.id === link.source);
                const targetNode = nodes.find(n => n.id === link.target);
                if (!sourceNode || !targetNode) return;

                const sourcePoint = map.latLngToLayerPoint([sourceNode.lat, sourceNode.lon]);
                const targetPoint = map.latLngToLayerPoint([targetNode.lat, targetNode.lon]);

                svg.append("line")
                    .attr("x1", sourcePoint.x)
                    .attr("y1", sourcePoint.y)
                    .attr("x2", targetPoint.x)
                    .attr("y2", targetPoint.y)
                    .attr("stroke", "#0b3c7a")
                    .attr("stroke-width", 3)
                    .attr("opacity", 0.9);
            });

            // Dibujar nodos
            nodes.forEach(node => {
                const point = map.latLngToLayerPoint([node.lat, node.lon]);

                // Círculo
                svg.append("circle")
                    .attr("cx", point.x)
                    .attr("cy", point.y)
                    .attr("r", 14)
                    .attr("fill", "#054eb5")
                    .attr("opacity", 0.85);

                // Etiqueta
                svg.append("text")
                    .attr("x", point.x)
                    .attr("y", point.y - 15)
                    .attr("text-anchor", "middle")
                    .text(node.name || node.id)
                    .attr("fill", "black");
            });
        }

        // -------------------- MAP EVENTS --------------------

        map.on("mousemove", e => {
            if (draggingNode) {
                draggingNode.lat = e.latlng.lat;
                draggingNode.lon = e.latlng.lng;
                draw();
            }
        });

        map.on("mouseup", () => {
            draggingNode = null;
        });

        map.on("zoom move", draw);


        // Primer dibujo
        draw();
        let lastInfo = [];  // Local cache of the last info of the node
        function actualizarNodo() {
            fetch("/info")
                .then(res => res.json())
                .then(data => {
                    console.log("Datos recibidos de /info:", data);
                    // Comparar con las últimas
                    const info = JSON.stringify(data);
                    const otherInfo = JSON.stringify(lastInfo);
                    draw()
                    if(info != otherInfo){
                        Object.assign(nodo, data);
                        // Update nodes and links for the map overlay
                        nodes = [nodo]; // main node
                        links = [];

                        data.neighbors.forEach(vecino => {
                            // Assign temporary coordinates if missing
                            if (!vecino.lat || !vecino.lon) {
                                const radius = 0.01;
                                const angle = Math.random() * 2 * Math.PI;
                                vecino.lat = nodo.lat + radius * Math.cos(angle);
                                vecino.lon = nodo.lon + radius * Math.sin(angle);
                            }

                            nodes.push(vecino);
                            links.push({ source: nodo.id, target: vecino.id });
                        });

                        // Now redraw the map overlay
                        draw();

                        // preserve client-side coordinates
                        if (draggingNode) {
                            nodo.lat = draggingNode.lat;
                            nodo.lon = draggingNode.lon;
                        }
                        draw();

                        // Node inputs
                        document.getElementById("nameInput").value = data.name;
                        document.getElementById("pswapInput").value = data.pswap || 0;
                        document.querySelectorAll(".roleChk").forEach(chk => {
                            chk.checked = data.roles.includes(chk.value);
                        });

                        // Attach node listeners
                        document.getElementById("nameInput").onchange = e =>
                            updateEntity({ type: "node", field: "name", value: e.target.value });

                        document.getElementById("pswapInput").onchange = e =>
                            updateEntity({ type: "node", field: "pswap", value: parseFloat(e.target.value) });

                        document.querySelectorAll(".roleChk").forEach(chk => {
                            chk.onchange = () => {
                                const roles = Array.from(document.querySelectorAll(".roleChk"))
                                    .filter(c => c.checked)
                                    .map(c => c.value);
                                updateEntity({ type: "node", field: "roles", value: roles });
                            };
                        });

                        // Neighbor table
                        const tbody = document.querySelector("#tabla-aristas tbody");

                        // Keep existing rows if they exist, otherwise create new ones
                        data.neighbors.forEach(vecino => {
                            // Look for an existing row by vecino.id
                            let tr = tbody.querySelector(`tr[data-id='${vecino.id}']`);
                            if (!tr) {
                                // Create a new row
                                tr = document.createElement("tr");
                                tr.dataset.id = vecino.id; // key to identify later
                                tr.innerHTML = `
                                    <td>${data.id}</td>
                                    <td>${vecino.name || vecino.id}</td>
                                    <td><input type="number" class="distInput" step="0.1"></td>
                                    <td><input type="number" class="pgenInput" min="0" max="1" step="0.01"></td>
                                `;
                                tbody.appendChild(tr);

                                const distInput = tr.querySelector(".distInput");
                                const pgenInput = tr.querySelector(".pgenInput");

                                // Attach handlers directly to the inputs
                                distInput.onchange = () =>
                                    updateEntity({ type: "neighbor", field: "distanceKm", value: parseFloat(distInput.value), neighborId: vecino.id });

                                pgenInput.onchange = () =>
                                    updateEntity({ type: "neighbor", field: "pgen", value: parseFloat(pgenInput.value), neighborId: vecino.id });
                            }

                            // Update input values only if the user is not focused on them
                            const distInput = tr.querySelector(".distInput");
                            const pgenInput = tr.querySelector(".pgenInput");
                            if (document.activeElement !== distInput) distInput.value = vecino.distanceKm;
                            if (document.activeElement !== pgenInput) pgenInput.value = vecino.pgen;
                        });


                        // Finally, redraw nodes and safely update lastInfo
                        draw();
                        lastInfo = JSON.parse(JSON.stringify(data));

                    }
                })
                .catch(console.error);
        }



        function updateEntity({ type, field, value, neighborId = null }) {
            // Pause polling immediately
            pausarActualizaciones();

            const payload = {
                lastUpdated: Date.now()
            };

            if (type === "node") {
                payload[field] = value;
            }

            if (type === "neighbor") {
                console.log("Cambiando distancia2");
                payload.source = nodo.id;
                payload.target = neighborId;
                payload[field] = value;
                console.log("Payload",payload);
            }

            return fetch("/update", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload)
            })
            .catch(err => console.error("Update error:", err))
            .finally(() => {
                // Resume polling after update finishes
                reanudarActualizaciones();
            });
        }

        const preOrdenes = document.getElementById("ordenesNodo");
        let ultimasOrdenes = [];  // cache local de las últimas órdenes

        function actualizarOrdenes() {
            fetch("/orders")
                .then(res => res.json())
                .then(data => {
                    if (!data || data.length === 0) {
                        preOrdenes.textContent = "No hay órdenes aún.";
                        return;
                    }

                    // Mostrar las órdenes
                    preOrdenes.textContent = data
                        .map((o, i) => `${i + 1}. ${JSON.stringify(o)}`)
                        .join("\n");

                    // Comparar con las últimas
                    const nuevasOrdenes = JSON.stringify(data);
                    const anterioresOrdenes = JSON.stringify(ultimasOrdenes);

                    if (nuevasOrdenes !== anterioresOrdenes) {
                        console.log("Órdenes nuevas detectadas, aplicando...");
                        console.log("Tiene un sleep de 500 ms");
                        data.forEach((orden, idx) => {
                            setTimeout(() => {
                                fetch("/operations", {
                                    method: "POST",
                                    headers: { "Content-Type": "application/json" },
                                    body: JSON.stringify(orden)
                                }).catch(err => console.error("Error aplicando orden:", err));
                            }, idx * 500); // ⏱ cada orden se retrasa 0.2s respecto a la anterior
                        });
                        ultimasOrdenes = data;
                    } else {
                        console.log("Órdenes iguales, no se reenvían");
                    }
                })
                .catch(err => {
                    console.error("Error al obtener órdenes:", err);
                    preOrdenes.textContent = "Error al obtener órdenes.";
                });
        }


        const evtSource = new EventSource("/updates/stream");
        evtSource.onmessage = function(event) {
            if (event.data === "mandate") {
                console.log("Mandato detectado, refrescando órdenes...");
                actualizarOrdenes();
            }
            else if(event.data === "update"){
                console.log("Updates detected, changing info...");
                actualizarNodo();
                draw();
                
            }
        };



        // Llamada inicial
        actualizarOrdenes();
        actualizarNodo();

        // Guardar los IDs de los intervalos
        let nodoInterval = setInterval(actualizarNodo, 2000);

        // Funciones para pausar y reanudar
        function pausarActualizaciones() {
            clearInterval(nodoInterval);
        // clearInterval(ordenesInterval);
            console.log("Actualizaciones pausadas");
        }

        function reanudarActualizaciones() {
            nodoInterval = setInterval(actualizarNodo, 2000);
        // ordenesInterval = setInterval(actualizarOrdenes, 2000);
            console.log("Actualizaciones reanudadas");
        }

        // Detectar cuando el usuario escribe en un input
        document.querySelectorAll("input, textarea").forEach(el => {
            el.addEventListener("focus", pausarActualizaciones);
            el.addEventListener("blur", reanudarActualizaciones);
        });
    };

</script>
</body>
</html>
