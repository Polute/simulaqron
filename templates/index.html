<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Simulaci√≥n Cu√°ntica</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_index.css') }}">
</head>
<body>
    <div class="container-flex">
            <!-- Columna izquierda: par√°metros f√≠sicos -->
            <div class="columna-izquierda" style="position: relative;">
                <h2>Editor de Mapa Cu√°ntico</h2>

                <div class="controles">
                    <button id="modoNodo" class="boton">üñåÔ∏è Crear Nodos</button>
                    <button id="modoArista" class="boton">üîó Crear Aristas</button>
                    <label>pgen:</label>
                    <input type="number" id="pgen" min="0" max="1" step="0.01" value="0.8">
                    <button id="zoomIn" class="boton">‚ûï</button>
                    <button id="zoomOut" class="boton">‚ûñ</button>
                    <button id="resetView" class="boton">üìç</button>
                    <button id="btnActualizarNodos">Actualizar nodos</button>
                </div>

                <input type="number" id="pgenInput" class="pgen-input" />
                <input type="text" id="nameInput" class="name-input" />

                <div id="mapa-wrapper" style="position: relative;">
                    <svg id="canvas"></svg>
                    <button id="btnrecibirInfo" style="
                        position: absolute;
                        top: 20px;
                        right: 20px;
                        z-index: 10;
                        padding: 6px 12px;
                        background-color: #4CAF50;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Actualizar info</button>
                </div>


                <h3>Par√°metros f√≠sicos</h3>
                <div style="display: flex; align-items: flex-start; gap: 40px;">
                    <div>
                        <label for="pswap">pswap (0.0 - 1.0):</label>
                        <input type="number" id="pswap" name="pswap" min="0" max="1" step="0.01" value="0.9">
                    </div>

                    <div>
                        <label for="tipo_canal">Tipo de canal cu√°ntico:</label>
                        <select id="tipo_canal" onchange="toggleCanalInput()">
                            <option value="numero">N√∫mero (0‚Äì1)</option>
                            <option value="matriz">Matriz 4x4</option>
                        </select>

                        <!-- Input num√©rico -->
                        <div id="canal_numero">
                            <label for="canal_cuantico">Valor:</label>
                            <input type="number" id="canal_cuantico" name="canal_cuantico" min="0" max="1" step="0.01" value="1.0">
                        </div>

                        <!-- Matriz 4x4 -->
                        <div id="canal_matriz" style="display:none; margin-top:5px;">
                            <label>Canal cu√°ntico (matriz 4x4):</label>
                            <table style="border-collapse: collapse; margin-top: 5px;">
                            <tbody>
                                <tr>
                                <td><input type="number" step="0.01" id="m00" value="1.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m01" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m02" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m03" value="0.0" class="matrix-input"></td>
                                </tr>
                                <tr>
                                <td><input type="number" step="0.01" id="m10" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m11" value="1.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m12" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m13" value="0.0" class="matrix-input"></td>
                                </tr>
                                <tr>
                                <td><input type="number" step="0.01" id="m20" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m21" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m22" value="1.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m23" value="0.0" class="matrix-input"></td>
                                </tr>
                                <tr>
                                <td><input type="number" step="0.01" id="m30" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m31" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m32" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m33" value="1.0" class="matrix-input"></td>
                                </tr>
                            </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                <br><br>
                <h3>Nodos</h3>
                <table id="tabla-nodos">
                    <thead>
                        <tr><th>ID</th>
                            <th>Nombre</th>
                            <th>Roles</th>
                            <th>pgen</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>

                <h3>Aristas</h3>
                <table id="tabla-aristas">
                    <thead>
                        <tr><th>Origen</th><th>Destino</th><th>Distancia (km)</th></tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button id="mostrarTopologia">Mostrar Topolog√≠a</button>
                <div id="topologiaTexto" style="white-space: pre-line; margin-top:10px;"></div>
            </div>


            <!-- Columna central: simulaci√≥n -->
            <div class="columna-centro">
                <h1>Simulaci√≥n Cu√°ntica</h1>
                <p>Este experimento simula el env√≠o de <strong>2 qubits EPR</strong> desde Alice a Bob, con opci√≥n de entrelazamiento puro o con ruido (estado de Werner usando un nodo Repeater).</p>

                <div class="resultado" id="resultado">
                    <strong>Resultado de la medici√≥n en Bob:</strong><br>
                    {{ resultado }}
                </div>

                <div class="estado" id="estado">
                    <strong>Estado:</strong> Esperando simulaci√≥n...
                </div>

                <div class="contador" id="contador">
                    <strong>Simulaciones realizadas:</strong> {{ contador }}
                </div>

                <div id="loading">Ejecutando simulaci√≥n... por favor espera.</div>
                <div id="cuenta"></div>

                <div style="margin-top: 1em;">
                    <label for="modo">Modo de env√≠o:</label>
                    <select id="modo">
                        <option value="puro">Entrelazamiento puro (Alice ‚Üí Bob)</option>
                        <option value="werner">Entrelazamiento con ruido (Alice ‚Üí Bob)</option>
                        <option value="swap">Entanglement Swap (Alice ‚Üí Charlie ‚Üê‚Üí Bob)</option>
                    </select>
                </div>
                <div style="margin-top: 1em; display: flex; align-items: center; gap: 1em;">
                    <div>
                        <label for="num_ParesEPR">N√∫mero de pares generados:</label><br>
                        <input type="number" id="num_ParesEPR" name="num_ParesEPR" min="1" max="10" value="2">
                    </div>

                    <div>
                        <label for="modo_tiempo">Generaci√≥n:</label><br>
                        <select id="modo_tiempo" name="modo_tiempo">
                            <option value="secuencial">Secuencial</option>
                            <option value="simultaneo">Simult√°neo</option>
                        </select>
                        <div id="decoherenciaInfo" style="margin-top: 0.5em; color: #555; display: none;">
                            En modo <strong>simult√°neo</strong>, el tiempo de decoherencia de los pares EPR puede diferir debido a la computaci√≥n paralela.
                        </div>
                    </div>
                </div>


                <button class="boton" onclick="iniciarSimulacion()">Iniciar Simulaci√≥n</button>
                 
                <!-- Secci√≥n de operaciones m√°s peque√±a -->
                <div class="columna-operaciones">
                    <h3>√ìrdenes Cu√°nticas</h3>
                        <!-- Paleta de bloques disponibles -->
                        <div class="paleta">
                            <div class="block op-doble" draggable="true" data-op="epr" data-src="Alice" data-dst="Bob">Alice ‚Üí Bob</div>
                            <div class="block op-simple" draggable="true" data-op="pur" data-src="Charlie">Charlie pur</div>
                            <div class="block op-doble" draggable="true" data-op="epr" data-src="Bob" data-dst="Charlie">Bob ‚Üí Charlie</div>
                            <div class="block op-doble" draggable="true" data-op="swap" data-src="Alice" data-dst="Charlie" data-helper="Bob">Alice ‚Üî Charlie (Bob)</div>
                        </div>

                    <!-- Workspace horizontal -->
                    <h4>Secuencia de √≥rdenes</h4>
                    <div id="workspace" class="workspace">
                        <!-- Aqu√≠ se soltar√°n los bloques -->
                    </div>
                    <button class="boton" onclick="mostrarOrdenes()">Exportar √ìrdenes</button>
                    <pre id="ordenesTexto"></pre>
                </div>
            </div>
            <!-- Columna derecha: historial -->
            <div class="columna-derecha">
                <h2>Historial de Resultados</h2>
                <table id="tabla-resultados">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Resultado</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Se llenar√° din√°micamente -->
                    </tbody>
                </table>
                <button class="boton" onclick="limpiarHistorial()">Limpiar historial</button>
            </div>
           </div> 
    </div>
    <script>// --- DRAG DESDE LA PALETA ---
        document.querySelectorAll(".paleta .block").forEach(block => {
            block.addEventListener("dragstart", e => {
                e.dataTransfer.setData("text", block.textContent);
                e.dataTransfer.setData("op", block.dataset.op);
                e.dataTransfer.setData("src", block.dataset.src || "");
                e.dataTransfer.setData("dst", block.dataset.dst || "");
                e.dataTransfer.setData("helper", block.dataset.helper || "");
                e.dataTransfer.setData("class", block.className);
                e.dataTransfer.setData("width", block.offsetWidth);
            });
        });

        // --- WORKSPACE ---
        const workspace = document.getElementById("workspace");

        workspace.addEventListener("dragover", e => e.preventDefault());

        workspace.addEventListener("drop", e => {
            e.preventDefault();

            const newBlock = document.createElement("div");
            newBlock.className = e.dataTransfer.getData("class");
            newBlock.textContent = e.dataTransfer.getData("text");
            newBlock.dataset.op = e.dataTransfer.getData("op");
            newBlock.dataset.src = e.dataTransfer.getData("src");
            newBlock.dataset.dst = e.dataTransfer.getData("dst");
            newBlock.dataset.helper = e.dataTransfer.getData("helper");
            const width = parseInt(e.dataTransfer.getData("width"), 10);
            newBlock.style.width = width + "px";

            workspace.appendChild(newBlock);
        });



        // Exportar √≥rdenes a texto
        function mostrarOrdenes() {
            const blocks = workspace.querySelectorAll(".block");
            const orders = [];
            blocks.forEach(b => {
                const op = b.dataset.op;
                if (op === "epr") {
                    orders.push(`${b.dataset.src}->${b.dataset.dst}`);
                } else if (op === "pur") {
                    orders.push(`${b.dataset.src} pur`);
                } else if (op === "swap") {
                    orders.push(`${b.dataset.src}<->${b.dataset.dst}(${b.dataset.helper})`);
                }
            });
            document.getElementById("ordenesTexto").textContent = orders.join("\n");
        }
    </script>
    <script>
        // Rol recibido desde Flask
        const rol = "{{ rol }}";

        // Nodos predefinidos
        const predefinedNodes = [
            { id: "node_alice", name: "Alice_pre",   x: 100, y: 100, pgen: 0.8, roles: ["emisor","receptor"] },
            { id: "node_bob",   name: "Bob_pre",     x: 300, y: 100, pgen: 0.7, roles: ["receptor","repeater"] },
            { id: "node_charlie", name: "Charlie_pre", x: 200, y: 250, pgen: 0.9, roles: ["emisor","repeater"] }
        ];

        let nodes = [];
        let links = [];
        if (rol === "master") {
            const nodo_info = JSON.parse('{{ nodo_info|tojson|safe }}');
            console.log("Objeto nodo_info recibido:", nodo_info);

            if (nodo_info.nodes && nodo_info.nodes.length > 0) {
                // Inicializar nodos
                nodes = nodo_info.nodes;
                console.log("Nodos inicializados desde nodo_info:", nodes);

                nodes.forEach(nodo => {
                    console.log("Procesando nodo:", nodo.name, "con vecinos:", nodo.neighbors);
                    if (Array.isArray(nodo.neighbors)) {
                        nodo.neighbors.forEach(vecino => {
                            const link = {
                                source: nodo.name,        // o nodo.id si prefieres
                                target: vecino.name,
                                distanciaKm: vecino.distanceKm
                            };
                            links.push(link);
                            console.log("Link a√±adido:", link);
                        });
                    }
                });
            } else {
                // Fallback: usar predefinidos
                nodes = predefinedNodes;
                console.log("Usando nodos predefinidos:", nodes);
                predefinedNodes.forEach(nodo => {
                    console.log("Procesando nodo predefinido:", nodo.name, "con vecinos:", nodo.neighbors);
                    if (Array.isArray(nodo.neighbors)) {
                        nodo.neighbors.forEach(vecino => {
                            const link = {
                                source: nodo.name,
                                target: vecino.name,
                                distanciaKm: vecino.distanceKm
                            };
                            links.push(link);
                            console.log("Link a√±adido (predefinido):", link);
                        });
                    }
                });
            }
        }

        console.log("Rol actual:", rol);
        console.log("Lista final de Nodes:", nodes);
        console.log("Lista final de Links:", links);

        document.getElementById("mostrarTopologia").addEventListener("click", () => {
            fetch("/topologia")
                .then(res => res.json())
                .then(data => {
                    let texto = "";
                    for (const nodo in data) {
                        texto += `Nodo ${nodo} conectado con: {${data[nodo].join(", ")}}\n`;
                    }
                    document.getElementById("topologiaTexto").textContent = texto;
                });
        });
    </script>

    <script>
        document.getElementById("modo_tiempo").addEventListener("change", function () {
            const info = document.getElementById("decoherenciaInfo");
            if (this.value === "simultaneo") {
                info.style.display = "block";
            } else {
                info.style.display = "none";
            }
        });
        document.getElementById("tipo_canal").addEventListener("change", function() {
            const tipo = this.value;
            document.getElementById("canal_numero").style.display = (tipo === "numero") ? "block" : "none";
            document.getElementById("canal_matriz").style.display = (tipo === "matriz") ? "block" : "none";
        });
    </script>
    <script>
        //-----------------------------------------MAPA-----------------------------------------------
        window.onload = function () {
            const svg = document.getElementById("canvas");
            const paramInput = document.getElementById("pgenInput");
            const nameInput = document.getElementById("nameInput");
            const pgenInput = document.getElementById("pgen");
            const modoNodoBtn = document.getElementById("modoNodo");
            const modoAristaBtn = document.getElementById("modoArista");
            const zoomInBtn = document.getElementById("zoomIn");
            const zoomOutBtn = document.getElementById("zoomOut");
            const resetViewBtn = document.getElementById("resetView");
            const actualizarNodosBtn = document.getElementById("btnActualizarNodos");
            const recibirInfoBtn = document.getElementById("btnrecibirInfo")

            let modoNodo = false;
            let modoArista = false;
            let selectedNode = null, draggingNode = null, linkStart = null;
            let transform = { x: 0, y: 0, k: 1 };
            let draggingMap = false;
            let dragStart = { x: 0, y: 0 };

            // Llama al renderizado
            draw();


            modoNodoBtn.onclick = () => {
                modoNodo = !modoNodo;
                modoArista = false;
                modoNodoBtn.classList.toggle("activo", modoNodo);
                modoAristaBtn.classList.remove("activo");
            };

            modoAristaBtn.onclick = () => {
                modoArista = !modoArista;
                modoNodo = false;
                modoAristaBtn.classList.toggle("activo", modoArista);
                modoNodoBtn.classList.remove("activo");
            };

            zoomInBtn.onclick = () => {
                transform.k *= 1.1;
                draw();
            };

            zoomOutBtn.onclick = () => {
                transform.k *= 0.9;
                draw();
            };

            resetViewBtn.onclick = () => {
                transform = { x: 0, y: 0, k: 1 };
                draw();
            };
            // Recibir informaci√≥n desde el master y actualizar el mapa
            recibirInfoBtn.addEventListener("click", () => {
                fetch("/actualizar_mapa")
                    .then(res => res.json())
                    .then(data => {
                        console.log("Datos recibidos de /actualizar_mapa:", data);

                        // Merge inteligente: no machacar cambios locales si son m√°s recientes
                        data.nodes.forEach(remoteNode => {
                            const localNode = nodes.find(n => n.id === remoteNode.id);
                            if (localNode) {
                                if (!localNode.lastUpdated || localNode.lastUpdated < remoteNode.lastUpdated) {
                                    Object.assign(localNode, remoteNode);
                                } else {
                                    console.log(`Manteniendo cambios locales en nodo ${localNode.name}`);
                                }
                            } else {
                                nodes.push(remoteNode);
                            }
                        });

                        // Recalcular links
                        links.length = 0;
                        nodes.forEach(nodo => {
                            if (Array.isArray(nodo.neighbors)) {
                                nodo.neighbors.forEach(vecino => {
                                    links.push({
                                        source: nodo.name,
                                        target: vecino.name,
                                        distanciaKm: vecino.distanceKm
                                    });
                                });
                            }
                        });

                        draw();
                        actualizarTablaNodos();
                        actualizarTablaAristas();
                    })
                    .catch(err => console.error("Error al recibir info de nodos:", err));
            });
            // Enviar todos los cambios a cada nodo
            actualizarNodosBtn.addEventListener("click", () => {
                nodes.forEach(node => {
                    const puerto = obtenerPuertoDesdeId(node.id);
                    if (!puerto) return;

                    fetch(`http://127.0.0.1:${puerto}/update`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            id: node.id,
                            name: node.name,
                            pgen: node.pgen,
                            roles: node.roles,
                            neighbors: node.neighbors,
                            parEPR: node.parEPR,
                            lastUpdated: Date.now() // importante: marcar timestamp
                        })
                    }).catch(err => console.error(`Error al actualizar nodo ${node.name}:`, err));
                });

                // Esperar un momento y luego refrescar el mapa completo desde master
                setTimeout(() => {
                    fetch("/actualizar_mapa")
                        .then(res => res.json())
                        .then(data => {
                            console.log("Datos recibidos de /actualizar_mapa:", data);

                            // Machacar nodes locales con lo que diga el master
                            nodes.length = 0;
                            nodes.push(...data.nodes);

                            // Recalcular links
                            links.length = 0;
                            nodes.forEach(nodo => {
                                if (Array.isArray(nodo.neighbors)) {
                                    nodo.neighbors.forEach(vecino => {
                                        links.push({
                                            source: nodo.name,
                                            target: vecino.name,
                                            distanciaKm: vecino.distanceKm
                                        });
                                    });
                                }
                            });

                            draw();
                            actualizarTablaNodos();
                            actualizarTablaAristas();
                        })
                        .catch(err => console.error("Error al actualizar mapa:", err));
                }, 1500);
            });

            function createNode(x, y) {
                const node = {
                    id: crypto.randomUUID(),          // identificador √∫nico
                    name: "Nodo_" + Date.now(),       // nombre inicial editable
                    roles: ["emisor","receptor","repeater"], // roles activos
                    x, y,
                    param: parseFloat(pgenInput.value)
                };
                nodes.push(node);
                draw();
                // Llamada al backend Flask para crear nodo en Simulaqron
                fetch(`/crear_nodos_simulaqron?nodos=${node.name}`)
                    .then(res => res.json())
                    .then(data => {
                        console.log("Respuesta del servidor:", data);
                    })
                    .catch(err => console.error("Error al crear nodo en Simulaqron:", err));

        }

        function createLink(sourceNode, targetNode) {
            const existe = links.some(link =>
                (link.source === sourceNode.name && link.target === targetNode.name) ||
                (link.source === targetNode.name && link.target === sourceNode.name)
            );
            if (existe) return;

            const distanciaKm = 50;
            const length = Math.hypot(targetNode.x - sourceNode.x, targetNode.y - sourceNode.y);

            links.push({ source: sourceNode.name, target: targetNode.name, length, distanciaKm });
            draw();

            fetch("/modificar_links", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    links: [{ source: sourceNode.name, target: targetNode.name }]
                })
            });
        }

        function draw() {
            svg.innerHTML = "";
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.setAttribute("transform", `translate(${transform.x},${transform.y}) scale(${transform.k})`);
            svg.appendChild(g);

            links.forEach(link => {
                const sourceNode = nodes.find(n => n.name === link.source);
                const targetNode = nodes.find(n => n.name === link.target);

                if (!sourceNode) {
                    console.warn(`Nodo no conectado a la red: ${link.source}`);
                    return;
                }
                if (!targetNode) {
                    console.warn(`Nodo no conectado a la red: ${link.target}`);
                    return;
                }

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", sourceNode.x);
                line.setAttribute("y1", sourceNode.y);
                line.setAttribute("x2", targetNode.x);
                line.setAttribute("y2", targetNode.y);
                line.setAttribute("class", "link");
                g.appendChild(line);
            });


            // Dibujar nodos
            nodes.forEach(node => {
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", node.x);
                circle.setAttribute("cy", node.y);
                circle.setAttribute("r", 20);
                circle.setAttribute("class", "node");

                circle.addEventListener("mousedown", e => {
                    if (modoArista) {
                        if (linkStart && linkStart !== node) {
                            createLink(linkStart, node);
                            linkStart = null;
                        } else {
                            linkStart = node;
                        }
                    } else {
                        draggingNode = node;
                    }
                });

                g.appendChild(circle);

                const nameLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
                nameLabel.setAttribute("x", node.x);
                nameLabel.setAttribute("y", node.y + 35);
                nameLabel.setAttribute("class", "label");
                nameLabel.textContent = node.name;
                g.appendChild(nameLabel);

                const paramLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
                paramLabel.setAttribute("x", node.x);
                paramLabel.setAttribute("y", node.y + 50);
                paramLabel.setAttribute("class", "label");
                paramLabel.textContent = "pgen = " + node.pgen;
                g.appendChild(paramLabel);
            });

            actualizarTablaNodos();
            actualizarTablaAristas();
        }

        svg.addEventListener("click", e => {
            if (!modoNodo) return;
            const pt = getMousePosition(e);
            createNode(pt.x, pt.y);
        });

        svg.addEventListener("mousedown", e => {
            if (!modoNodo && !modoArista) {
                draggingMap = true;
                dragStart = { x: e.clientX, y: e.clientY };
            }
        });

        svg.addEventListener("mousemove", e => {
            if (draggingNode) {
                const pt = getMousePosition(e);
                draggingNode.x = pt.x;
                draggingNode.y = pt.y;
                draw();
            } else if (draggingMap) {
                const dx = e.clientX - dragStart.x;
                const dy = e.clientY - dragStart.y;
                transform.x += dx;
                transform.y += dy;
                dragStart = { x: e.clientX, y: e.clientY };
                draw();
            }
        });

        svg.addEventListener("mouseup", () => {
            draggingNode = null;
            draggingMap = false;
        });

        svg.addEventListener("mouseleave", () => {
            draggingNode = null;
            draggingMap = false;
        });

        paramInput.addEventListener("change", () => {
            if (selectedNode) {
                selectedNode.pgen = parseFloat(pgenInput.value);
                pgenInput.style.display = "none";
                draw();
            }
        });

        nameInput.addEventListener("change", () => {
            if (selectedNode) {
                selectedNode.name = nameInput.value;
                selectedNode.id = nameInput.value;
                nameInput.style.display = "none";
                draw();
            }
        });

        function getMousePosition(e) {
            const rect = svg.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left - transform.x) / transform.k,
                y: (e.clientY - rect.top - transform.y) / transform.k
            };
        }
        function obtenerPuertoDesdeId(id) {
            const mapa = {
                "node_alice": 5000,
                "node_bob": 5002,
                "node_charlie": 5003
                // Agrega m√°s si tienes m√°s nodos
            };
            return mapa[id];
        }
        function actualizarTablaNodos() {
            const tbody = document.querySelector("#tabla-nodos tbody");
            tbody.innerHTML = "";

            nodes.forEach(node => {
                const fila = document.createElement("tr");

                // ID (solo lectura)
                const idCell = document.createElement("td");
                idCell.textContent = node.id;
                fila.appendChild(idCell);

                // Nombre (editable)
                const nameCell = document.createElement("td");
                const nameInput = document.createElement("input");
                nameInput.value = node.name;
                nameInput.onchange = () => {
                    const oldName = node.name;
                    const newName = nameInput.value;

                    // Actualizar el nombre del nodo
                    node.name = newName;

                    // Actualizar vecinos que lo referencian
                    nodes.forEach(n => {
                        n.neighbors.forEach(vecino => {
                            if (vecino.name === oldName) {
                                vecino.name = newName;
                            }
                        });
                    });

                    // Actualizar enlaces
                    links.forEach(link => {
                        if (link.source === oldName) link.source = newName;
                        if (link.target === oldName) link.target = newName;
                    });

                    // Enviar cambio de nombre al backend del nodo
                    const puerto = obtenerPuertoDesdeId(node.id);
                    if (puerto) {
                        fetch(`http://localhost:${puerto}/update`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ name: newName })
                        });
                    }

                    draw();
                };
                nameCell.appendChild(nameInput);
                fila.appendChild(nameCell);

                // Roles (checkboxes)
                const rolesCell = document.createElement("td");
                ["emisor", "receptor", "repeater"].forEach(role => {
                    const chk = document.createElement("input");
                    chk.type = "checkbox";
                    chk.checked = node.roles.includes(role);
                    chk.onchange = () => {
                        if (chk.checked && !node.roles.includes(role)) {
                            node.roles.push(role);
                        } else {
                            node.roles = node.roles.filter(r => r !== role);
                        }
                        draw();
                    };
                    const lbl = document.createElement("label");
                    lbl.textContent = role;
                    rolesCell.appendChild(chk);
                    rolesCell.appendChild(lbl);
                });
                fila.appendChild(rolesCell);

                // Param
                const pgenCell = document.createElement("td");
                const pgenInput = document.createElement("input");
                pgenInput.type = "number";
                pgenInput.step = "0.01";
                pgenInput.min = "0";
                pgenInput.max = "1";
                pgenInput.value = node.pgen;
                pgenInput.onchange = () => {
                    node.pgen = parseFloat(pgenInput.value);
                    draw();
                };
                pgenCell.appendChild(pgenInput);
                fila.appendChild(pgenCell);

                tbody.appendChild(fila);
            });
        }

        function actualizarTablaAristas() {
            const tbody = document.querySelector("#tabla-aristas tbody");
            tbody.innerHTML = "";
            links.forEach(link => {
                const fila = document.createElement("tr");

                const origenCell = document.createElement("td");
                origenCell.textContent = link.source;
                fila.appendChild(origenCell);

                const destinoCell = document.createElement("td");
                destinoCell.textContent = link.target;
                fila.appendChild(destinoCell);

                const distCell = document.createElement("td");
                const distInput = document.createElement("input");
                distInput.type = "number";
                distInput.value = link.distanciaKm;
                distInput.onchange = () => {
                    const nuevaDistancia = parseFloat(distInput.value);
                    link.distanciaKm = nuevaDistancia;

                    // üîë Actualizar tambi√©n el neighbors del nodo origen
                    const origenNode = nodes.find(n => n.name === link.source);
                    if (origenNode && Array.isArray(origenNode.neighbors)) {
                        const vecino = origenNode.neighbors.find(v => v.name === link.target);
                        if (vecino) {
                            vecino.distanceKm = nuevaDistancia;
                        }
                    }
                };
                distCell.appendChild(distInput);
                fila.appendChild(distCell);

                tbody.appendChild(fila);
            });
        }

        draw();
    };

        //-----------------------------------------SIMULACI√ìN------------
        function getDistancia(id) {
            const link = links.find(l => l.id === id);
            return link ? link.distanciaKm : 0;
        }

        const nombres_nodos = nodes.map(n => n.id).join(" ");
        //fetch(`/crear_nodos_simulaqron?nodos=${nombres_nodos}`);

        function iniciarSimulacion() {
            const modo = document.getElementById("modo").value;
            const num_ParesEPR = document.getElementById("num_ParesEPR").value;
            console.log("Iniciando simulaci√≥n √∫nica");

            const dist_ab = getDistancia("dist_ab");
            const dist_ac = getDistancia("dist_ac");
            const dist_cb = getDistancia("dist_cb");

            const pgen = document.getElementById("pgen").value;
            const pswap = document.getElementById("pswap").value;

            // Nodos con su pgen
            const pgen_nodos = nodes.map(n => `${n.name}:${n.pgen}`).join(",");

            // Distancias en formato origen:destino:valor
            const distancias = links.map(l => `${l.source}:${l.target}:${l.distanciaKm}`).join(",");

            const modo_tiempo = document.getElementById("modo_tiempo").value;
            const canal_cuantico = getCanalCuantico();

            fetch(`/simular?modo=${modo}&num_ParesEPR=${num_ParesEPR}&pgen_nodos=${pgen_nodos}&distancias=${distancias}&pswap=${pswap}&modo_tiempo=${modo_tiempo}&canal_cuantico=${encodeURIComponent(canal_cuantico)}`)
                .then(response => response.json())
                .then(data => {
                    document.getElementById("resultado").innerHTML =
                        "<strong>Resultado de la medici√≥n en Bob:</strong><br>" + data.resultado;
                    document.getElementById("estado").innerHTML =
                        "<strong>Estado:</strong> Informaci√≥n enviada correctamente desde Alice a Bob.";
                    document.getElementById("contador").innerHTML =
                        "<strong>Simulaciones realizadas:</strong> " + data.contador;
                    actualizarTabla(data.historial);
                    document.getElementById("loading").style.display = "none";
                    document.getElementById("cuenta").innerText = "";
                });
        }


        function mostrarResultado(data) {
            document.getElementById("resultado").innerHTML =
                "<strong>Resultado de la medici√≥n en Bob:</strong><br>" + data.resultado;
            document.getElementById("estado").innerHTML =
                "<strong>Estado:</strong> Informaci√≥n enviada correctamente desde Alice a Bob.";
            document.getElementById("contador").innerHTML =
                "<strong>Simulaciones realizadas:</strong> " + data.contador;
            actualizarTabla(data.historial);
            document.getElementById("loading").style.display = "none";
        }


        function actualizarTabla(historial) {
            const tbody = document.querySelector("#tabla-resultados tbody");
            tbody.innerHTML = "";
            historial.forEach(linea => {
                const fila = document.createElement("tr");
                const partes = linea.split(":");
                fila.innerHTML = `<td>${partes[0].trim()}</td><td>${partes[1].trim()}</td>`;
                tbody.appendChild(fila);
            });
        }
        function limpiarHistorial() {
            fetch("/limpiar_historial")
                .then(response => response.json())
                .then(data => {
                    document.getElementById("resultado").innerHTML =
                        "<strong>Resultado de la medici√≥n en Bob:</strong><br>Historial borrado.";
                    document.getElementById("estado").innerHTML =
                        "<strong>Estado:</strong> Historial limpiado correctamente.";
                    document.getElementById("contador").innerHTML =
                        "<strong>Simulaciones realizadas:</strong> 0";
                    actualizarTabla([]);
                });
        }
        let modoAnterior = document.getElementById("modo").value;

        document.getElementById("modo").addEventListener("change", () => {
            const nuevoModo = document.getElementById("modo").value;
            if (nuevoModo !== modoAnterior) {
                fetch("/limpieza_docs")
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === "ok") {
                            document.getElementById("estado").innerHTML =
                                "<strong>Estado:</strong> Qubits limpiados al cambiar de modo.";
                            console.log("Qubits limpiados correctamente.");
                        } else {
                            document.getElementById("estado").innerHTML =
                                "<strong>Estado:</strong> Error al limpiar qubits.";
                            console.warn("Error al limpiar qubits.");
                        }
                        modoAnterior = nuevoModo;
                    });
            }
        });
        document.getElementById("num_ParesEPR").addEventListener("change", () => {
            const nuevoModo = document.getElementById("num_ParesEPR").value;
            if (nuevoModo !== modoAnterior) {
                fetch("/limpieza_docs")
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === "ok") {
                            document.getElementById("estado").innerHTML =
                                "<strong>Estado:</strong> Qubits limpiados al cambiar de num_ParesEPR generados.";
                            console.log("Qubits limpiados correctamente.");
                        } else {
                            document.getElementById("estado").innerHTML =
                                "<strong>Estado:</strong> Error al limpiar qubits.";
                            console.warn("Error al limpiar qubits.");
                        }
                        modoAnterior = nuevoModo;
                    });
            }
        });

        function getCanalCuantico() {
            const tipo = document.getElementById("tipo_canal").value;
            if (tipo === "numero") {
                return document.getElementById("canal_cuantico").value;
            } else {
                const matrix = [];
                for (let i = 0; i < 4; i++) {
                    const row = [];
                    for (let j = 0; j < 4; j++) {
                        row.push(parseFloat(document.getElementById(`m${i}${j}`).value));
                    }
                    matrix.push(row);
                }
                return JSON.stringify(matrix);
            }
        }


    </script>
</body>
</html>
