<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Quantum simulation</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}?v={{ time }}">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />

</head>
<body class="day">
    <!-- Sidebar -->
    <div id="mySidebar" class="sidebar">
    <span class="closebtn" onclick="closeSidebar()">&times;</span>
    <a href="#" onclick="showSimulator()">Simulator</a>
    <a href="#" onclick="showAnalytics()">Analytics</a>
    </div>

    <!-- Button to open sidebar -->
    <button class="openbtn" onclick="openSidebar()">‚ò∞ Menu</button>

    <!-- Interactive icon for day/night -->
    <span id="toggleIcon">üåû</span>

    <!-- Main menu -->
    <div id="simulatorSection">
        <div class="container-flex">
            <!-- Left column: Physics parameters -->
            <div class="left-column" style="position: relative;">
                <h2>Quantum Map</h2>

                <div class="controls">
                    <div id="node_link_controls" class="controls">
                        <button id="nodeMode" class="button">üñåÔ∏è Create Node</button>
                        <button id="linkMode" class="button">üîó Create Link</button>
                    </div>
                    <button id="resetView" class="button">üìç</button>
                    <button id="btnUpdateNodes">Update nodes</button>
                </div>
                <input type="text" id="nameInput" class="name-input" />

                <div id="map-wrapper" style="position: relative;">
                    <div id="map"></div>
                </div>


                <h3>Physics parameters</h3>
                <div style="display: flex; align-items: flex-start; gap: 40px;">
                    <div id="physics_full_controls">
                        <label for="channel_type">Quantum channel definition type:</label>
                        <select id="channel_type" onchange="toggleCanalInput()">
                            <option value="number">Number (0-1)</option>
                            <option value="matrix">Matrix 4x4</option>
                        </select>

                        <!-- Numeric input -->
                        <div id="number_channel">
                            <label for="quantum_channel">Value:</label>
                            <input type="number" id="quantum_channel" name="quantum_channel" min="0" max="1" step="0.01" value="1.0">
                        </div>

                        <!-- matrix 4x4 -->
                        <div id="matrix_channel" style="display:none; margin-top:5px;">
                            <label>Quantum Channel (matrix 4x4):</label>
                            <table style="border-collapse: collapse; margin-top: 5px;">
                            <tbody>
                                <tr>
                                <td><input type="number" step="0.01" id="m00" value="1.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m01" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m02" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m03" value="0.0" class="matrix-input"></td>
                                </tr>
                                <tr>
                                <td><input type="number" step="0.01" id="m10" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m11" value="1.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m12" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m13" value="0.0" class="matrix-input"></td>
                                </tr>
                                <tr>
                                <td><input type="number" step="0.01" id="m20" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m21" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m22" value="1.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m23" value="0.0" class="matrix-input"></td>
                                </tr>
                                <tr>
                                <td><input type="number" step="0.01" id="m30" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m31" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m32" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m33" value="1.0" class="matrix-input"></td>
                                </tr>
                            </tbody>
                            </table>
                        </div>
                    </div>
                    <div id="tcoh_container" style="display:none; margin-top:10px;">
                        <label for="tcoh_value">tcoh (s):</label>
                        <input type="number" id="tcoh_value" min="0" max="1000" step="1" value="10">
                    </div>

                </div>
                <br><br>
                <h3>Nodes</h3>
                <table id="nodes-table">
                    <thead>
                        <tr><th>ID</th>
                            <th>Name</th>
                            <th>Roles</th>
                            <th>Pswap</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>

                <h3>Links</h3>
                <table id="links-table">
                    <thead>
                        <tr><th>Source</th><th>Target</th><th>Distance (km)</th><th>Pgen</th></tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button id="showTopology">Show Topology</button>
                <div id="topologyText" style="white-space: pre-line; margin-top:10px;"></div>
            </div>


            <!-- Central column: simulation -->
            <div class="center-column">
                <div id="simulation-header">
                    <h1>Quantum Simulation</h1>
                    <p>This experiment simulates sending <strong>2 EPR qubits</strong> from Alice to Bob, 
                        with the option of pure entanglement or entanglement with noise (Werner state using a 
                        Repeater node).</p>

                    <div class="result" id="result">
                        <strong>Resultado de la medici√≥n en Bob:</strong><br>
                        {{ result }}
                    </div>

                    <div class="state" id="state">
                        <strong>State:</strong> Waiting simulation...
                    </div>

                    <div class="counter" id="counter">
                        <strong>Simulations carried out:</strong> {{ counter }}
                    </div>

                    <div id="loading">Running simulation...</div>
                    <div id="counter2"></div>

                    <div style="margin-top: 1em;">
                        <label for="modo">Sending mode:</label>
                        <select id="modo">
                            <option value="puro">Pure entanglement (Alice ‚Üí Bob)</option>
                            <option value="werner">Entanglement with noise (Alice ‚Üí Bob)</option>
                            <option value="swap">Entanglement Swapping (Alice ‚Üí Charlie ‚Üê‚Üí Bob)</option>
                        </select>
                    </div>
                    <div style="margin-top: 1em; display: flex; align-items: center; gap: 1em;">
                        <div>
                            <label for="num_PairsEPR">Number of pairs to generate:</label><br>
                            <input type="number" id="num_PairsEPR" name="num_PairsEPR" min="1" max="10" value="2">
                        </div>

                        <div>
                            <label for="time_mode">Generation:</label><br>
                            <select id="time_mode" name="time_mode">
                                <option value="sequential">Sequential</option>
                                <option value="simultaneous">Simultaneous</option>
                            </select>
                            <div id="decoherenciaInfo" style="margin-top: 0.5em; color: #555; display: none;">
                                En modo <strong>simult√°neo</strong>, el tiempo de decoherencia de los pares EPR puede diferir debido a la computaci√≥n paralela.
                            </div>
                        </div>
                    </div>


                    <button class="button" onclick="initSimulation()">Start Simulation</button>
                </div>    
                 
                <!-- Operations column -->
                <div class="operations-column">
                    <h3>Quantum orders</h3>
                        <!-- Blocks pallette -->
                        <div id="pallette" class="pallette">
                            <!-- Fixed blocks -->
                            <div class="block op-double" draggable="true" data-op="epr">‚öõÔ∏è Entanglement</div>
                            <div class="block op-double" draggable="true" data-op="swap">üîó Swapping</div>
                            <div class="block op-simple" draggable="true" data-op="pur">üß™ Purification</div>
                        </div>

                    <!-- Horizontal Workspace  -->
                    <h4>Order secuence
                        <button id="clean-workspace" class="button">Clean Workspace</button>
                        <!-- Block removal zone -->
                        <div id="trash-frame" class="trash-frame">
                            üóëÔ∏è
                        </div>
                    </h4>
                    <div id="workspace" class="workspace">
                        <!-- Blocks will be dropped here -->
                    </div>
                    <label for="mode_select">Export mode:</label>
                    <select id="mode_select" onchange="toggleMode()">
                        <option value="normal">Normal</option>
                        <option value="loop">Loop</option>
                    </select>

                    <br><br>

                    <!-- Normal export button -->
                    <div id="normal_mode">
                        <button class="button" onclick="showOrders()">Export Orders</button>
                        <button class="button" onclick="downloadHistoryAsTXT()">Save History</button>
                    </div>

                    <!-- Loop controls -->
                    <div id="loop_mode" style="display:none;">
                        <input type="number" id="time_loop" min="1" max="10" step="1" value="1">
                        <label for="time_loop">Seconds between executions</label>

                        <input type="number" id="loop_limit" min="1" max="100" step="1" value="5">
                        <label for="loop_limit">Number of loops</label>

                        <br><br>
                        <button class="button" onclick="startLoop(true)">Export Orders (Loop)</button>
                        <button class="button" onclick="startLoop(false)">STOP Loop</button>
                        <button class="button" onclick="downloadHistoryAsTXT()">Save History</button>
                    </div>
                    <pre id="ordersText"></pre>
                </div>
            </div>
            <div class="right-column">
                <h2>History</h2>
                <div id="results-table-wrapper">
                    <table id="results-table">
                        <thead></thead>
                        <tbody></tbody>
                    </table>
                </div>
                <button class="button" onclick="cleanHistory()">Clean history</button>
            </div>
        </div>
    </div>
    <!-- Analytics section -->
    <div id="analyticsSection" style="display:none">
        <h2>Analytics</h2>
        <!-- Control to choose number of nodes --> 
         <div style="margin-bottom: 15px;"> 
            <label for="numNodesInput"><strong>Number of nodes:</strong></label> 
            <input type="number" id="numNodesInput" value="3" min="1" style="width:60px;"> 
            <button id="updateNodesBtn">Update</button> 
        </div>
        <div id="nodesContainer"></div>
    </div>

    <script>
        function setStylesheet(mode) {
            const head = document.head;
            let link = document.getElementById("sectionStyles");
            if (!link) {
                link = document.createElement("link");
                link.rel = "stylesheet";
                link.id = "sectionStyles";
                head.appendChild(link);
            }
            if (mode === "simulator") {
                link.href = "{{ url_for('static', filename='css/styles.css') }}?v={{ time}}";
            } else if (mode === "analytics") {
                link.href = "{{ url_for('static', filename='css/analytics.css') }}?v={{ time }}";
            }
        }

        // Sidebar
        function openSidebar() {
            document.getElementById("mySidebar").style.width = "250px";
        }
        function closeSidebar() {
            document.getElementById("mySidebar").style.width = "0";
        }

        // Mostrar secciones
        function showSimulator() {
            closeSidebar();
            document.getElementById("simulatorSection").style.display = "block";
            document.getElementById("analyticsSection").style.display = "none";
            setStylesheet("simulator"); 
        }
        function showAnalytics() {
            closeSidebar();
            document.getElementById("simulatorSection").style.display = "none";
            document.getElementById("analyticsSection").style.display = "block";
            setStylesheet("analytics"); 
            loadNodes();
        }

        // Day/Night toggle
        const icon = document.getElementById("toggleIcon");
        const body = document.body;
        icon.addEventListener("click", () => {
            body.classList.toggle("day");
            body.classList.toggle("night");
            icon.textContent = body.classList.contains("day") ? "üåû" : "üåô";
        });

        // Build URLs dynamically
        function buildUrls(num) {
            const urls = [];
            for (let i = 0; i < num; i++) {
                if (i === 0) urls.push("http://localhost:5000/info");
                else urls.push(`http://localhost:${5001 + i}/info`);
            }
            return urls;
        }

        // Button to update number of nodes
        document.getElementById("updateNodesBtn").addEventListener("click", async () => {
            await loadNodes();
        });

        // Load nodes based on input
        async function loadNodes() {
            const num = parseInt(document.getElementById("numNodesInput").value, 10);
            const urls = buildUrls(num);
            await renderNodes(urls);
        }
        

        // Render node cards
        async function renderNodes(urls) {
            const container = document.getElementById("nodesContainer");
            container.innerHTML = "";

            for (const url of urls) {
                const resp = await fetch(url);
                if (!resp.ok) {
                    container.textContent = `Error fetching ${url}: ${resp.status} ${resp.statusText}`;
                    return;
                }

                const data = await resp.json();

                const card = document.createElement("div");
                card.className = "node-card";
                card.innerHTML = `
                    <h3>${data.name} (${data.id})</h3>
                    <p class="roles"><strong>Roles:</strong> ${data.roles.join(", ")}</p>
                    <p><strong>Neighbors:</strong> ${
                        data.neighbors.map(n => `${n.id} (${n.distanceKm} km)`).join(", ")
                    }</p>
                    <div class="table-wrapper">
                    <table class="analytics-table">
                        <thead>
                        <tr>
                            <th>ID</th><th>Neighbor</th><th>Distance</th><th>Status</th>
                            <th>t_gen</th><th>t_recv</th><th>Œît</th><th>w_out</th>
                        </tr>
                        </thead>
                        <tbody>
                        ${data.pairEPR.map(p => `
                            <tr>
                            <td>${p.id}</td>
                            <td>${p.neighbor}</td>
                            <td>${p.distancia_nodos}</td>
                            <td class="state ${p.state}">${p.state}</td>
                            <td>${p.t_gen}</td>
                            <td>${p.t_recv}</td>
                            <td>${p.t_diff}</td>
                            <td>${p.w_out}</td>
                            </tr>
                        `).join("")}
                        </tbody>
                    </table>
                    </div>`;
                container.appendChild(card);
            }
        }



    </script>
    <script>
        // --- DRAG DESDE LA PALETA ---
        document.querySelectorAll(".pallette .block").forEach(block => {
            block.addEventListener("dragstart", e => {
                e.dataTransfer.setData("text", block.textContent);
                e.dataTransfer.setData("op", block.dataset.op);
                e.dataTransfer.setData("src", block.dataset.src || "");
                e.dataTransfer.setData("dst", block.dataset.dst || "");
                e.dataTransfer.setData("helper", block.dataset.helper || "");
                e.dataTransfer.setData("class", block.className);
                e.dataTransfer.setData("width", block.offsetWidth);
            });
        });

        // --- WORKSPACE ---
        const workspace = document.getElementById("workspace");
        const limpiarBtn = document.getElementById("clean-workspace");

        // Global EPR history: keeps all pairs even if nodes are hidden
        let eprHistoryGlobal = [];

        limpiarBtn.addEventListener("click", () => {
            eprHistoryGlobal = [];
            workspace.innerHTML = ""; // Clear history
        });

        // --- Internal workspace dragging ---
        workspace.addEventListener("dragstart", e => {
            if (e.target.classList.contains("block")) {
                e.target.classList.add("dragging");
                e.dataTransfer.setData("text/plain", null); // for Firefox
            }
        });

        workspace.addEventListener("dragend", e => {
            e.target.classList.remove("dragging");
        });

        workspace.addEventListener("dragover", e => {
            e.preventDefault();
            const dragging = workspace.querySelector(".dragging");
            if (!dragging) return;

            const afterElement = getDragAfterElement(workspace, e.clientX);
            if (afterElement == null) {
                workspace.appendChild(dragging);
            } else {
                workspace.insertBefore(dragging, afterElement);
            }
        });

        function getDragAfterElement(container, x) {
            const draggableElements = [...container.querySelectorAll(".block:not(.dragging)")];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = x - box.left - box.width / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // --- Drop from pallette ---
        workspace.addEventListener("drop", e => {
            e.preventDefault();

            const newBlock = document.createElement("div");
            newBlock.className = e.dataTransfer.getData("class");
            newBlock.dataset.op = e.dataTransfer.getData("op");
            newBlock.draggable = true;
            const width = parseInt(e.dataTransfer.getData("width"), 10);
            newBlock.style.width = width + "px";

            if (newBlock.dataset.op === "node") {
                newBlock.dataset.src = e.dataTransfer.getData("src");
                newBlock.textContent = newBlock.dataset.src;
            } else {
                newBlock.textContent = newBlock.dataset.op.toUpperCase();
            }

            workspace.appendChild(newBlock);

            updatingBlocks();
        });
        const trashFrame = document.getElementById("trash-frame");

        // Allow drop
        trashFrame.addEventListener("dragover", e => {
            e.preventDefault();
            trashFrame.classList.add("dragover");
        });

        // Delete block when dropped onto the trash bin
        trashFrame.addEventListener("drop", e => {
            e.preventDefault();
            const dragging = workspace.querySelector(".dragging");

            if (dragging) {
                const op = dragging.dataset.op;
                if (op === "epr") {
                    const src = dragging.dataset.src;
                    const dst = dragging.dataset.dst;

                    if (src && dst) {
                        deletingOneEpr(src, dst);
                        console.log("EPR removed:", { src, dst });
                    }

                }else if (op === "pur") {
                    if (dragging.dataset.usedPairs) {
                        const used = JSON.parse(dragging.dataset.usedPairs);
                        
                        // Restore ONLY the first consumed EPR (the one PUR actually removes)
                        const e1 = used[0];

                        // Securing the existence of the list
                        if (!eprHistoryGlobal[e1.src]) eprHistoryGlobal[e1.src] = [];
                        if (!eprHistoryGlobal[e1.dst]) eprHistoryGlobal[e1.dst] = [];

                        // Restoring one copy in each node
                        eprHistoryGlobal[e1.src].push(e1);
                        eprHistoryGlobal[e1.dst].push(e1);

                        console.log("PUR removed ‚Üí restored 1 EPR:", e1);
                        console.log("Global history after restoring PUR:", eprHistoryGlobal);
                    }
                } else if (op === "swap") {
                    const id1 = dragging.dataset.src;
                    const id2 = dragging.dataset.dst;
                    const helper = dragging.dataset.helper;

                    if (helper && id1) {
                        deletingOneEpr(helper, id1);
                        console.log("SWAP removed EPR helper-node1:", helper, id1);
                    }
                    if (helper && id2) {
                        deletingOneEpr(helper, id2);
                        console.log("SWAP removed EPR helper-node2:", helper, id2);
                    }

                }

                dragging.remove();
                updatingBlocks();

                console.log("Global history after deleting block:", eprHistoryGlobal);
            }

            trashFrame.classList.remove("dragover");
        });
        function deletingOneEpr(src, dst) {
            if (eprHistoryGlobal[src]) {
                const i = eprHistoryGlobal[src].findIndex(
                    e => e.src === src && e.dst === dst
                );
                if (i !== -1) eprHistoryGlobal[src].splice(i, 1);
            }

            if (eprHistoryGlobal[dst]) {
                const j = eprHistoryGlobal[dst].findIndex(
                    e => e.src === src && e.dst === dst
                );
                if (j !== -1) eprHistoryGlobal[dst].splice(j, 1);
            }
        }


        // Clear visual effect on exit
        trashFrame.addEventListener("dragleave", e => {
            trashFrame.classList.remove("dragover");
        });

        function hasEprWith(node, target) {
            const eprs = eprHistoryGlobal[node] || [];
            return eprs.some(e => {
                // Normalize the pair
                const pair = [e.src, e.dst].sort().join("-");
                const expected = [node, target].sort().join("-");
                if (pair === expected) return true;

                // If the entry has a helper, accept it as a valid swap-generated link
                if (e.helper) {
                const indirectPair = [e.src, e.dst].sort().join("-");
                if (indirectPair === expected) return true;
                }

                return false;
            });
        }




        function updatingBlocks() {
            const blocks = Array.from(workspace.querySelectorAll(".block"));
            const actualizarInfoBtn = 

            // Inicialize history on each node
            blocks.forEach(b => {
                if (b.dataset.op === "node") {
                    if (!eprHistoryGlobal[b.dataset.src]) eprHistoryGlobal[b.dataset.src] = [];
                }
            });

            blocks.forEach((b, idx) => {
                if (b.dataset.finalizado) return;

                if (b.dataset.op === "epr") {
                    // Searching nodes, even if they aren't visible
                    const prevNode = blocks.slice(0, idx).reverse().find(bb => bb.dataset.op === "node");
                    const nextNode = blocks.slice(idx + 1).find(bb => bb.dataset.op === "node");

                    if (prevNode && nextNode) {
                        b.dataset.src = prevNode.dataset.src;
                        b.dataset.dst = nextNode.dataset.src;
                        b.textContent = `${prevNode.dataset.src} ‚Üí ${nextNode.dataset.src}`;
                        b.dataset.finalizado = true;

                        // Saving EPR in the global history
                        const newEpr = { src: prevNode.dataset.src, dst: nextNode.dataset.src };

                        eprHistoryGlobal[prevNode.dataset.src].push(newEpr);
                        eprHistoryGlobal[nextNode.dataset.src].push(newEpr);

                        console.log("EPR added:", newEpr);
                        console.log("Global history:", eprHistoryGlobal);


                        // Hiding nodes, but keeping the history
                        prevNode.style.display = "none";
                        nextNode.style.display = "none";
                    } else {
                        b.textContent = "‚öõÔ∏è EPR üö´";
                    }

                }else if (b.dataset.op === "pur") {
                    let posiblesCandidatos = [];

                    for (let node in eprHistoryGlobal) {
                        const eprs = eprHistoryGlobal[node] || [];
                        
                        // Searching for nodes used in a EPR
                        const creados = eprs.filter(e => e.src === node || e.dst === node );

                        const paresContados = {};
                        creados.forEach(e => {
                            const key = [e.src, e.dst].sort().join("-"); 
                            paresContados[key] = (paresContados[key] || 0) + 1;
                        });

                        for (let k in paresContados) {
                            if (paresContados[k] >= 2) {
                                const paresUsar = creados.filter(e => [e.src, e.dst].sort().join("-") === k).slice(0, 2);
                                posiblesCandidatos.push({ node, paresUsar });
                                break;
                            }
                        }
                    }

                    if (posiblesCandidatos.length === 0) {
                        b.textContent = "üß™ Purification üö´";
                    } else {
                        // Create a dropdown selector with a block‚Äëstyle appearance
                        const select = document.createElement("select");
                        select.style.fontSize = "0.85em";
                        select.style.padding = "3px 6px";
                        select.style.borderRadius = "4px";
                        select.style.border = "1px solid #aaa";
                        select.style.background = "#fff";
                        select.style.cursor = "pointer";
                        select.style.marginLeft = "5px";

                        const defaultOption = document.createElement("option");
                        defaultOption.textContent = "Select a node";
                        defaultOption.disabled = true;
                        defaultOption.selected = true;
                        select.appendChild(defaultOption);

                        posiblesCandidatos.forEach(candidato => {
                            const option = document.createElement("option");
                            option.value = candidato.node;
                            option.textContent = candidato.node;
                            select.appendChild(option);
                        });

                        b.textContent = "üß™ Purificar: ";
                        b.appendChild(select);

                        select.addEventListener("change", () => {
                            const nodeSeleccionado = select.value;
                            const elegido = posiblesCandidatos.find(c => c.node === nodeSeleccionado);
                            const { node, paresUsar } = elegido;

                            // Asign data to the block
                            b.dataset.dst = node;
                            b.dataset.finalizado = true;
                            b.dataset.usedPairs = JSON.stringify(paresUsar);
                            b.textContent = `üß™ ${node}`;

                            // Deleting 1 EPR consumed in both nodes
                            const e1 = paresUsar[0];
                            deletingOneEpr(e1.src, e1.dst);

                            console.log("üß™ PUR applied:", elegido);
                            console.log("Global history after PUR:", eprHistoryGlobal);

                            // Removing selector after selecting
                            select.remove();
                        });
                    }
                }
                else if (b.dataset.op === "swap") {
                    // SWAP: use nodes even if hidden, validate with history
                    const helperNode = blocks.slice(0, idx).reverse().find(bb => bb.dataset.op === "node");
                    const nextTwoNodes = blocks.slice(idx + 1).filter(bb => bb.dataset.op === "node").slice(0, 2);

                    if (helperNode && nextTwoNodes.length === 2) {
                        const [n1, n2] = nextTwoNodes;
                        b.dataset.src = n1.dataset.src;
                        b.dataset.dst = n2.dataset.src;
                        b.dataset.helper = helperNode.dataset.src;

                        console.log("=== SWAP DEBUG ===");
                        console.log("Helper node:", helperNode.dataset.src);
                        console.log("Target nodes:", n1.dataset.src, n2.dataset.src);
                        console.log("Global history after SWAP:", eprHistoryGlobal[helperNode.dataset.src]);

                        // Validate that helper has EPRs with both target nodes
                        const valid1 = hasEprWith(helperNode.dataset.src, n1.dataset.src);
                        const valid2 = hasEprWith(helperNode.dataset.src, n2.dataset.src);


                        console.log("SWAP validation results:", valid1, valid2);
                        console.log("==================");

                        if (valid1 && valid2) {
                            // Mark block as finalized
                            b.dataset.finalizado = true;
                            b.textContent = `${n1.dataset.src}<=>${n2.dataset.src}(${helperNode.dataset.src})`;

                            // Record new swapped EPR in global history
                            const newSwap = {
                                src: n1.dataset.src,
                                dst: n2.dataset.src,
                                helper: helperNode.dataset.src
                            };
                            eprHistoryGlobal[n1.dataset.src].push(newSwap);
                            eprHistoryGlobal[n2.dataset.src].push(newSwap);

                            console.log("SWAP added:", newSwap);
                            console.log("Global history after SWAP:", eprHistoryGlobal);

                            // Hide nodes visually
                            helperNode.style.display = "none";
                            n1.style.display = "none";
                            n2.style.display = "none";
                        } else {
                            b.textContent = "‚öõÔ∏è Swap üö´";
                        }
                    } else {
                        b.textContent = "‚öõÔ∏è Swap üö´";
                    }
                }
            });
        }
        function generateUniqueId() {
            return Math.random().toString(36).substr(2, 9); 
        }
        function toggleMode() {
            const mode = document.getElementById("mode_select").value;

            const normalDiv = document.getElementById("normal_mode");
            const loopDiv = document.getElementById("loop_mode");

            if (mode === "normal") {
                normalDiv.style.display = "block";
                loopDiv.style.display = "none";
            } else {
                normalDiv.style.display = "none";
                loopDiv.style.display = "block";
            }
        }
        let loopInterval = null; // global reference

        function startLoop(start) {
            if (start) {
                // START LOOP
                const intervalSeconds = parseInt(document.getElementById("time_loop").value);
                const loopLimit = parseInt(document.getElementById("loop_limit").value);

                let count = 0;

                // Prevent multiple loops running at the same time
                if (loopInterval !== null) {
                    clearInterval(loopInterval);
                }

                loopInterval = setInterval(() => {
                    showOrders();
                    count++;

                    if (count >= loopLimit) {
                        clearInterval(loopInterval);
                        loopInterval = null;
                        console.log("Loop finished");
                    }
                }, intervalSeconds * 1000);

                console.log("Loop started");

            } else {
                // STOP LOOP
                if (loopInterval !== null) {
                    clearInterval(loopInterval);
                    loopInterval = null;
                    console.log("Loop stopped manually");
                }
            }
        }

        // Export orders using the same history
        function showOrders() {
            const blocks = workspace.querySelectorAll(".block");
            const orders = [];
            const eprHistory = [];
            const ordersPerNode = {}; // Object that gather every order of each node


            // Build a name‚Äëto‚Äëid mapping
            const nameToId = {};
            nodes.forEach(n => { 
                nameToId[n.name] = n.id;
            });

            blocks.forEach((b, i) => {
                if (b.style.display === "none") return; // ignoring hidden nodes

                const op = b.dataset.op;

                if (op === "epr") {
                    const srcName = b.dataset.src || "???";
                    const dstName = b.dataset.dst || "???";

                    if (!srcName || !dstName) {
                        orders.push(`ERROR: EPR block in position ${i} without src or dst`);
                        return;
                    }

                    orders.push(`ENTANGLEMENT: ${srcName} creates EPR with ${dstName} [pos ${i}]`);
                    eprHistory.push({ src: srcName, dst: dstName });

                    // IDs to send to the backend
                    const srcId = nameToId[srcName];
                    const dstId = nameToId[dstName];

                    // generate a single id for both
                    const eprId = generateUniqueId();

                    if (!ordersPerNode[srcId]) ordersPerNode[srcId] = [];
                    ordersPerNode[srcId].push({ id: eprId, comand: "generate EPR", target: dstId });

                    if (!ordersPerNode[dstId]) ordersPerNode[dstId] = [];
                    ordersPerNode[dstId].push({ id: eprId, comand: "receive EPR", source: srcId });

                }else if (op === "pur") {
                    const dstName = b.dataset.dst;

                    // Retrieve the last EPR from the history to know with whom it is purified
                    const lastEpr = eprHistory[eprHistory.length - 1];
                    const srcName = lastEpr ? lastEpr.src : null;

                    console.log("Who makes the pur:", dstName, "| and with who shares it:", srcName);

                    if (!dstName || !srcName) {
                        orders.push(`ERROR: PUR block in position ${i} without an assigned node or without a prior EPR`);
                        return;
                    }

                    // Count EPRs where this node is the receiver
                    const eprCount = eprHistory.filter(e => e.dst === dstName || e.src === dstName).length;
                    if (eprCount < 2) {
                        orders.push(`ERROR: ${dstName} does not have enough prior EPRs to purify [pos ${i}]`);
                    } else {
                        orders.push(`PURIFICATION: ${dstName} purifies two prior EPRs [pos ${i}]`);
                        const srcId = nameToId[srcName];
                        const dstId = nameToId[dstName];
                        const purId = generateUniqueId();
                        if (!ordersPerNode[dstId]) ordersPerNode[dstId] = [];
                        ordersPerNode[dstId].push({
                            id: purId,
                            comand: "purify",
                            detail: "two previous EPRs",
                            with: srcId
                        });
                    }
                } else if (op === "swap") {
                    const id1Name = b.dataset.src;
                    const id2Name = b.dataset.dst;
                    const helperName = b.dataset.helper;

                    if (!id1Name || !id2Name || !helperName) {
                        orders.push(`ERROR: Incomplete SWAP block at position ${i} (missing src, dst, or helper)`);
                        return;
                    }

                    // Validate that helper has EPRs with both target nodes
                    const valid1 = hasEprWith(helperName, id1Name);
                    const valid2 = hasEprWith(helperName, id2Name);
                    console.log("HISTORY: ",eprHistory);
                    if (!valid1 || !valid2) {
                        console.log("HISTORY2: ",eprHistory);
                        orders.push(`ERROR: ${helperName} has no prior EPRs with ${id1Name} and ${id2Name} for SWAP [pos ${i}]`);
                    } else {
                        orders.push(`SWAP: ${helperName} executes entanglement swapping between ${id1Name} and ${id2Name} [pos ${i}]`);

                        const helperId = nameToId[helperName];
                        const id1Id = nameToId[id1Name];
                        const id2Id = nameToId[id2Name];
                        const swapId = generateUniqueId();
                        // Action for the helper
                        if (!ordersPerNode[helperId]) ordersPerNode[helperId] = [];
                        ordersPerNode[helperId].push({ id: swapId, comand: "swap", with: [id1Id, id2Id] });

                        // Notify id1 and id2 that they receive a SWAP
                        if (!ordersPerNode[id1Id]) ordersPerNode[id1Id] = [];
                        ordersPerNode[id1Id].push({ 
                            id: swapId, 
                            comand: "received swap", 
                            with: [id2Id],          // with whom the swap is performed
                            thanks_to: helperId    // thanks to whom it was carried out
                        });

                        if (!ordersPerNode[id2Id]) ordersPerNode[id2Id] = [];
                        ordersPerNode[id2Id].push({ 
                            id: swapId, 
                            comand: "received swap", 
                            with: [id1Id],          // with whom the swap is performed
                            thanks_to: helperId    // thanks to whom it was carried out
                        });
                    }


                } else if (op === "node") {
                    orders.push(`NODE: ${b.dataset.src} [pos ${i}]`);
                } else {
                    orders.push(`ERROR: Unknown operation "${op}" [pos ${i}]`);
                }
            });

            // Display on screen using names
            document.getElementById("ordersText").textContent = orders.join("\n");

            // Automatically send to the /mandate endpoint using IDs
            fetch("/mandate", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(ordersPerNode)
            })
            .then(response => response.json())
            .then(data => console.log("Instructions sent to the server:", data))
            .catch(error => console.error("Error sending instructions:", error));
        }


        function createDynamicBlocks(nodes) {
            const pallette = document.getElementById("pallette");

            nodes.forEach(node => {
                // Evitar bloques duplicados fijos (EPR y Pur)
                if (node.name.includes("epr") || node.name.includes("Pur") ||node.name.includes("swap")) return;
                // üîç Si ya existe un bloque con este ID, no crearlo again
                const yaExiste = pallette.querySelector(`[data-id="${node.id}"]`);
                if (yaExiste) return;

                const block = document.createElement("div");
                block.className = "block op-simple";
                block.draggable = true;

                // Guardamos info del node en dataset para an√°lisis posterior
                block.dataset.op = "node";
                block.dataset.src = node.name;    // nombre del node
                block.dataset.id = node.id;       // id del node
                block.dataset.neighbors = JSON.stringify(node.neighbors); // neighbors en JSON
                block.dataset.pairEPR = JSON.stringify(node.pairEPR);

                // Texto del bloque = nombre del node
                block.textContent = node.name;

                // Drag & Drop
                block.addEventListener("dragstart", e => {
                    e.dataTransfer.setData("text", block.textContent);
                    e.dataTransfer.setData("op", block.dataset.op);
                    e.dataTransfer.setData("src", block.dataset.src);
                    e.dataTransfer.setData("id", block.dataset.id);
                    e.dataTransfer.setData("neighbors", block.dataset.neighbors);
                    e.dataTransfer.setData("pairEPR", block.dataset.pairEPR);
                    e.dataTransfer.setData("class", block.className);
                    e.dataTransfer.setData("width", block.offsetWidth);
                });

                pallette.appendChild(block);
            });
        }
        function ajustarColumnasSegunNodos(node_info) {
            if (Array.isArray(node_info.nodes) && node_info.nodes.length > 0) {
                const todosPre = node_info.nodes.every(n => n.id.endsWith("pre"));

                const header = document.getElementById("simulation-header");
                const derecha = document.querySelector(".right-column");
                const operaciones = document.querySelector(".operations-column");

                const nodeLinkControls = document.getElementById("node_link_controls");
                const physicsControls = document.getElementById("physics_full_controls");
                const tcohContainer = document.getElementById("tcoh_container");

                if (todosPre) {
                    // --- MODO NORMAL ---
                    if (header) header.style.display = "block";
                    if (derecha) derecha.style.flex = "1.5";
                    if (operaciones) operaciones.style.display = "none";

                    // show normal controls
                    nodeLinkControls.style.display = "flex";
                    physicsControls.style.display = "block";
                    tcohContainer.style.display = "none";

                    f5 = true;

                } else {
                    // --- MODO ESPECIAL ---
                    if (header) header.style.display = "none";
                    if (derecha) derecha.style.flex = "2";
                    if (operaciones) operaciones.style.display = "block";

                    // hide node/link creation + channel definition
                    nodeLinkControls.style.display = "none";
                    physicsControls.style.display = "none";

                    // show tcoh input
                    tcohContainer.style.display = "block";
                }
            }
        }


    </script>
              <!-- Leaflet JS -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>

      <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Rol recibido desde Flask
        const rol = "{{ rol }}";
        let nodes = [];
        let links = [];
        let f5 = false;
        if (rol === "master") {
            const node_info = JSON.parse('{{ node_info|tojson|safe }}');
            console.log("Received node_info object:", node_info);
            if (node_info.nodes && node_info.nodes.length > 0) {
                // Inicializar nodes desde el backend (ya incluye predefinidos si hace falta)
                nodes = node_info.nodes;
                console.log("Nodes initialized:", nodes);

                // aplicar ajuste de columnas
                ajustarColumnasSegunNodos(node_info);

                nodes.forEach(node => {
                    if (Array.isArray(node.neighbors)) {
                        node.neighbors.forEach(neighbor => {
                            if (!neighbor) return; // skip null/undefined neighbors
                            const link = {
                                source: node.id,
                                target: neighbor.id,
                                distanciaKm: neighbor.distanceKm,
                                lat: neighbor.lat,
                                lon: neighbor.lon,
                                pgen: neighbor.pgen,
                                pgenOverride: neighbor.pgenOverride || false
                            };
                            links.push(link);
                        });
                    }
                });
            }
        }

        console.log("Current role:", rol);
        console.log("Final list of Nodes:", nodes);
        console.log("Final list of Links:", links);



        // Crear bloques para los nodes detectados
        document.addEventListener("DOMContentLoaded", () => {
            createDynamicBlocks(nodes);
        });



        document.getElementById("showTopology").addEventListener("click", () => {
            fetch("/topologia")
                .then(res => res.json())
                .then(data => {
                    let texto = "";
                    for (const node in data) {
                        texto += `Node ${node} connected with: {${data[node].join(", ")}}\n`;
                    }
                    document.getElementById("topologyText").textContent = texto;
                });
        });

        document.getElementById("time_mode").addEventListener("change", function () {
            const info = document.getElementById("decoherenciaInfo");
            if (this.value === "simultaneous") {
                info.style.display = "block";
            } else {
                info.style.display = "none";
            }
        });
        document.getElementById("channel_type").addEventListener("change", function() {
            const tipo = this.value;
            document.getElementById("number_channel").style.display = (tipo === "number") ? "block" : "none";
            document.getElementById("matrix_channel").style.display = (tipo === "matrix") ? "block" : "none";
        });

        function obtenerPuertoDesdeId(id) {
            const mapa = {
                "node_rectorado_upm": 5000,
                "node_cedint_upm": 5002,
                "node_etsiinf_upm": 5003,
                "node_cait_upm": 5004
            };
            return mapa[id];
        }
        function calculatePgen(distKm, Latt = 22, p0 = 0.5) {
            console.log("Recalculating pgen from distance: ", distKm)
            return p0 * Math.exp(-distKm / Latt);
        }

        //-----------------------------------------MAP-----------------------------------------------------
        window.onload = function () {
            // -------------------- INITIAL SETUP --------------------
            const mapDiv = document.getElementById("map"); // Leaflet map container
            const nameInput = document.getElementById("nameInput");
            const nodeModeBtn = document.getElementById("nodeMode");
            const linkModeBtn = document.getElementById("linkMode");
            const resetViewBtn = document.getElementById("resetView");
            const updateNodesBtn = document.getElementById("btnUpdateNodes");
            const receiveInfoBtn = document.getElementById("btnreceiveInfo");

            let nodeMode = false;
            let linkMode = false;
            let selectedNode = null;
            let draggingNode = null;
            let linkStart = null;

            // -------------------- INITIALIZE LEAFLET MAP --------------------
            console.log("Initializing Leaflet map...");

            const map = L.map('map').setView([40.4168, -3.7038], 11); // Centered in Madrid
            console.log("Map object created:", map);

            // Add OpenStreetMap tiles
            const tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors'
            }).addTo(map);
            
            tileLayer.on('tileloadstart', function(e) {
                console.log("Tile load started:", e.tile.src);
            });

            tileLayer.on('tileload', function(e) {
                console.log("Tile loaded:", e.tile.src);
            });

            tileLayer.on('tileerror', function(e) {
                console.error("Tile load error:", e.tile.src);
            });

            // Tell Leaflet to recalc map size
            map.invalidateSize();
            console.log("Map invalidateSize called");
            // Add SVG layer on top of the map for custom nodes and links
            const svgLayer = L.svg().addTo(map);
            const svg = d3.select("#map").select("svg");
            if (nodes.length > 0) {
                console.log("Drawing initial nodes", nodes);
                draw();
            }
            console.log("SVG layer added:", svg.node());
            // Optional: add scale control
            L.control.scale().addTo(map);

            // -------------------- MODE TOGGLING --------------------
            resetViewBtn.onclick = () => {
                map.setView([40.4168, -3.7038], 11);
            };

            nodeModeBtn.onclick = () => {
                nodeMode = !nodeMode;
                linkMode = false;
                nodeModeBtn.classList.toggle("active", nodeMode);
                linkModeBtn.classList.remove("active");
            };

            linkModeBtn.onclick = () => {
                linkMode = !linkMode;
                nodeMode = false;
                linkModeBtn.classList.toggle("active", linkMode);
                nodeModeBtn.classList.remove("active");
            };
            // Bot√≥n Update info como control de Leaflet
            const updateBtn = L.control({ position: 'topright' });

            updateBtn.onAdd = function(map) {
                // Crear el bot√≥n
                const btn = L.DomUtil.create('button', '');
                btn.innerHTML = "Update info";

                // Estilos
                btn.style.padding = "6px 12px";
                btn.style.backgroundColor = "#4CAF50";
                btn.style.color = "white";
                btn.style.border = "none";
                btn.style.borderRadius = "4px";
                btn.style.cursor = "pointer";

                // Evitar que el clic se propague al mapa
                L.DomEvent.disableClickPropagation(btn);

                // Acci√≥n al hacer clic
                L.DomEvent.on(btn, 'click', () => {
                    // Aqu√≠ va el c√≥digo de receiveInfoBtn
                    if (f5) {
                        location.reload();
                        f5 = false;
                    }

                    fetch("/actualizar_mapa")
                        .then(res => res.json())
                        .then(data => {
                            console.log("Data from /actualizar_mapa:", data);

                            // Remove dead nodes
                            const aliveNodes = new Set(data.nodes.map(n => n.id));
                            for (let i = nodes.length - 1; i >= 0; i--) {
                                if (!aliveNodes.has(nodes[i].id)) nodes.splice(i, 1);
                            }

                            // Merge remote nodes with local nodes intelligently
                            data.nodes.forEach(remoteNode => {
                                const localNode = nodes.find(n => n.id === remoteNode.id);
                                if (localNode) {
                                    if (!localNode.lastUpdated || localNode.lastUpdated < remoteNode.lastUpdated) {
                                        Object.assign(localNode, remoteNode);
                                    }
                                } else nodes.push(remoteNode);
                            });

                            // Recalculate links
                            links.length = 0;
                            const linksDict = {};
                            nodes.forEach(node => {
                                const ts = node.lastUpdated || 0;
                                if (Array.isArray(node.neighbors)) {
                                    node.neighbors.forEach(neighbor => {
                                        const nodeKey = node.id || node.name;
                                        const neighborKey = neighbor.id || neighbor.name;
                                        const par = [nodeKey, neighborKey].sort().join("-");
                                        if (!linksDict[par] || ts > linksDict[par].lastUpdated) {
                                            linksDict[par] = {
                                                source: nodeKey,
                                                target: neighborKey,
                                                targetLat: neighbor.lat,
                                                targetLon: neighbor.lon,
                                                distanciaKm: neighbor.distanceKm,
                                                pgen: neighbor.pgen,
                                                pgenOverride: neighbor.pgenOverride || false,
                                                lastUpdated: ts
                                            };
                                        }
                                    });
                                }
                            });
                            Object.values(linksDict).forEach(l => {
                                links.push({ source: l.source, target: l.target, targetLat: l.lat,
                                                targetLon: l.lon, distanciaKm: l.distanciaKm, pgen: l.pgen,
                                                pgenOverride: l.pgenOverride });
                            });

                            createDynamicBlocks(nodes);
                            draw();
                            actualizarTablaNodos();
                            actualizarTablaAristas();
                        })
                        .catch(err => console.error("Error fetching nodes:", err));
                });

                return btn;
            };

            // A√±adir el bot√≥n al mapa
            updateBtn.addTo(map);
            // Fullscreen button as a Leaflet control
            const fullscreenBtn = L.control({ position: 'topright' });

            fullscreenBtn.onAdd = function(map) {
                const btn = L.DomUtil.create('button', '');
                btn.innerHTML = "Fullscreen";

                // Styles
                btn.style.padding = "6px 12px";
                btn.style.backgroundColor = "#2196F3";
                btn.style.color = "white";
                btn.style.border = "none";
                btn.style.borderRadius = "4px";
                btn.style.cursor = "pointer";
                btn.style.marginLeft = "5px";

                // Prevent map click propagation
                L.DomEvent.disableClickPropagation(btn);

                // Toggle fullscreen
                L.DomEvent.on(btn, 'click', () => {
                    const wrapper = document.getElementById("map-wrapper");

                    if (!document.fullscreenElement) {
                        wrapper.requestFullscreen().catch(err => {
                            console.error("Fullscreen error:", err);
                        });
                    } else {
                        document.exitFullscreen();
                    }
                });

                return btn;
            };

            fullscreenBtn.addTo(map);


            updateNodesBtn.addEventListener("click", () => {
                nodes.forEach(node => {
                    const puerto = obtenerPuertoDesdeId(node.id);
                    console.log(puerto);
                    if (!puerto) return;
                    const neighborsSimetricos = [];
                    nodes.forEach(other => {
                        if (other.id !== node.id) {
                            const esteVecino = node.neighbors.find(v => v.id === other.id);
                            const otroVecino = other.neighbors.find(v => v.id === node.id);
                            const distanciaKm = (esteVecino && esteVecino.distanceKm) || (otroVecino && otroVecino.distanceKm);
                            const pgen = (esteVecino && esteVecino.pgen) || (otroVecino && otroVecino.pgen);
                            const pgenOverride = (esteVecino && esteVecino.pgenOverride) || (otroVecino && otroVecino.pgenOverride) || false;
                            // default: target coords
                            let lat = other.lat;
                            let lon = other.lon;

                            // if they coincide with the current node, switch
                            if (lat === node.lat && lon === node.lon) {
                                lat = node.lat;
                                lon = node.lon;
                            }
                            if (distanciaKm !== undefined){
                                neighborsSimetricos.push({ id: other.id, distanceKm: distanciaKm, 
                                    lat, lon, pgen, 
                                    pgenOverride: (esteVecino && esteVecino.pgenOverride) || 
                                    (otroVecino && otroVecino.pgenOverride) || false });
                            }
                        }
                    });
                    console.log(neighborsSimetricos);
                    fetch(`http://127.0.0.1:${puerto}/update`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            id: node.id,
                            name: node.name,
                            pswap: node.pswap,
                            roles: node.roles,
                            neighbors: neighborsSimetricos,
                            pairEPR: node.pairEPR,
                            lastUpdated: Date.now()
                        })
                    }).catch(err => console.error(`Error updating node ${node.id}:`, err));
                });
            });

            // -------------------- NODE CREATION --------------------
            function createNode(lat, lon) {
                const node = {
                    id: crypto.randomUUID(),
                    name: "node_" + Date.now(),
                    roles: ["emisor", "receptor", "repeater"],
                    lat, lon,
                    pswap: 0.8,
                    neighbors: []
                };
                nodes.push(node);
                draw();

                fetch(`/crear_nodos_simulaqron?nodos=${node.id}`)
                    .then(res => res.json())
                    .then(data => console.log("Server response:", data))
                    .catch(err => console.error("Error creating node in Simulaqron:", err));
            }

            // -------------------- LINK CREATION --------------------
            function createLink(sourceNode, targetNode) {
                const exists = links.some(l => (l.source === sourceNode.id && l.target === targetNode.id) || (l.source === targetNode.id && l.target === sourceNode.id));
                if (exists) return;

                const distanciaKm = 50;
                const pgen = 0.9;
                links.push({ source: sourceNode.id, target: targetNode.id, distanciaKm, pgen });

                fetch("/modificar_links", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ links: [{ source: sourceNode.id, target: targetNode.id }] })
                });

                draw();
            }

            // -------------------- DRAW FUNCTION --------------------
            function draw() {
                svg.selectAll("*").remove();

                // Draw links
                links.forEach(link => {
                    const sourceNode = nodes.find(n => n.id === link.source);
                    const targetNode = nodes.find(n => n.id === link.target);
                    if (!sourceNode || !targetNode) return;

                    const sourcePoint = map.latLngToLayerPoint([sourceNode.lat, sourceNode.lon]);
                    const targetPoint = map.latLngToLayerPoint([targetNode.lat, targetNode.lon]);

                    svg.append("line")
                        .attr("x1", sourcePoint.x)
                        .attr("y1", sourcePoint.y)
                        .attr("x2", targetPoint.x)
                        .attr("y2", targetPoint.y)
                        .attr("stroke", "#0b3c7a")     // Dark blue
                        .attr("stroke-width", 3)
                        .attr("opacity", 0.9);

                });

                // Draw nodes
                nodes.forEach(node => {
                    const point = map.latLngToLayerPoint([node.lat, node.lon]);

                    // Circle
                    svg.append("circle")
                        .attr("cx", point.x)
                        .attr("cy", point.y)
                        .attr("r", 14)                 // Bigger node
                        .attr("fill", "#054eb5")       // Fixed blue
                        .attr("opacity", 0.85)

                        .on("mousedown", () => {
                            if (linkMode) {
                                if (linkStart && linkStart !== node) createLink(linkStart, node);
                                linkStart = node;
                            } else draggingNode = node;
                        });

                    // Label
                    svg.append("text")
                        .attr("x", point.x)
                        .attr("y", point.y - 15)
                        .attr("text-anchor", "middle")
                        .text(node.name)
                        .attr("fill", "black");
                });

                actualizarTablaNodos();
                actualizarTablaAristas();
            }

            // -------------------- MAP EVENTS --------------------
            map.on("click", e => {
                if (!nodeMode) return;
                createNode(e.latlng.lat, e.latlng.lng);
            });

            map.on("mousemove", e => {
                if (draggingNode) {
                    draggingNode.lat = e.latlng.lat;
                    draggingNode.lon = e.latlng.lng;
                    draw();
                }
            });

            map.on("mouseup", () => {
                draggingNode = null;
            });

            map.on("zoom move", draw); // redraw nodes/links on zoom/pan

            // -------------------- NAME EDIT --------------------
            nameInput.addEventListener("change", () => {
                if (selectedNode) {
                    selectedNode.name = nameInput.value;
                    nameInput.style.display = "none";
                    draw();
                }
            });

            // -------------------- TABLE UPDATES --------------------
            function actualizarTablaNodos() {
                const tbody = document.querySelector("#nodes-table tbody");
                tbody.innerHTML = "";
                nodes.forEach(node => {
                    const fila = document.createElement("tr");

                    // ID
                    const idCell = document.createElement("td");
                    idCell.textContent = node.id;
                    fila.appendChild(idCell);

                    // Name
                    const nameCell = document.createElement("td");
                    const nameInput = document.createElement("input");
                    nameInput.value = node.name;
                    nameInput.onchange = () => {
                        const oldName = node.name;
                        node.name = nameInput.value;
                        nodes.forEach(n => n.neighbors.forEach(v => { if (v.name === oldName) v.name = node.name; }));
                        links.forEach(l => { if (l.source === oldName) l.source = node.name; if (l.target === oldName) l.target = node.name; });
                        draw();
                    };
                    nameCell.appendChild(nameInput);
                    fila.appendChild(nameCell);

                    // Roles
                    const rolesCell = document.createElement("td");
                    ["emisor", "receptor", "repeater"].forEach(role => {
                        const chk = document.createElement("input");
                        chk.type = "checkbox";
                        chk.checked = node.roles.includes(role);
                        chk.onchange = () => {
                            if (chk.checked && !node.roles.includes(role)) node.roles.push(role);
                            else node.roles = node.roles.filter(r => r !== role);
                            draw();
                        };
                        const lbl = document.createElement("label");
                        lbl.textContent = role;
                        rolesCell.appendChild(chk);
                        rolesCell.appendChild(lbl);
                    });
                    fila.appendChild(rolesCell);

                    // pswap
                    const pswapCell = document.createElement("td");
                    const pswapInput = document.createElement("input");
                    pswapInput.type = "number";
                    pswapInput.step = "0.01";
                    pswapInput.min = "0";
                    pswapInput.max = "1";
                    pswapInput.value = node.pswap || 0.8;
                    pswapInput.onchange = () => { node.pswap = parseFloat(pswapInput.value); draw(); };
                    pswapCell.appendChild(pswapInput);
                    fila.appendChild(pswapCell);

                    tbody.appendChild(fila);
                });
            }

            function actualizarTablaAristas() {
                const tbody = document.querySelector("#links-table tbody");
                tbody.innerHTML = "";
                const vistos = new Set();

                links.forEach(link => {
                    const key = [link.source, link.target].sort().join("-");
                    if (vistos.has(key)) return;
                    vistos.add(key);

                    const fila = document.createElement("tr");

                    // source & target
                    ["source", "target"].forEach(prop => {
                        const td = document.createElement("td");
                        td.textContent = link[prop];
                        fila.appendChild(td);
                    });

                    // ---------------- DISTANCE ----------------
                    const distCell = document.createElement("td");
                    const distInput = document.createElement("input");
                    distInput.type = "number";
                    distInput.value = link.distanciaKm;

                    distInput.onchange = () => {
                        const val = parseFloat(distInput.value);

                        links.forEach(l => {
                            if ([l.source, l.target].sort().join("-") === key) {
                                l.distanciaKm = val;

                                // --- NEW: auto-update pgen only if override is OFF ---
                                if (!l.pgenOverride) {
                                    l.pgen = calculatePgen(val);
                                }
                            }
                        });

                        nodes.forEach(n => {
                            if (n.id === link.source) {
                                const neighbor = n.neighbors.find(v => v.id === link.target);
                                if (neighbor) {
                                    neighbor.distanceKm = val;

                                    // --- NEW: auto-update pgen only if override is OFF ---
                                    if (!neighbor.pgenOverride) {
                                        neighbor.pgen = calculatePgen(val);
                                    }
                                }
                            }
                            if (n.id === link.target) {
                                const neighbor = n.neighbors.find(v => v.id === link.source);
                                if (neighbor) {
                                    neighbor.distanceKm = val;

                                    // --- NEW: auto-update pgen only if override is OFF ---
                                    if (!neighbor.pgenOverride) {
                                        neighbor.pgen = calculatePgen(val);
                                    }
                                }
                            }
                        });

                        actualizarTablaAristas(); // refresh table
                    };

                    distCell.appendChild(distInput);
                    fila.appendChild(distCell);

                    // ---------------- PGEN ----------------
                    const pgenCell = document.createElement("td");
                    const pgenInput = document.createElement("input");
                    pgenInput.type = "number";
                    pgenInput.step = "0.01";
                    pgenInput.min = "0";
                    pgenInput.max = "1";
                    pgenInput.value = link.pgen !== undefined ? link.pgen : "";

                    pgenInput.onchange = () => {
                        const val = parseFloat(pgenInput.value);

                        links.forEach(l => {
                            if ([l.source, l.target].sort().join("-") === key) {
                                l.pgen = val;

                                // --- NEW: manual edit activates override ---
                                l.pgenOverride = true;
                            }
                        });

                        nodes.forEach(n => {
                            if (n.id === link.source) {
                                const neighbor = n.neighbors.find(v => v.id === link.target);
                                if (neighbor) {
                                    neighbor.pgen = val;

                                    // --- NEW: manual edit activates override ---
                                    neighbor.pgenOverride = true;
                                }
                            }
                            if (n.id === link.target) {
                                const neighbor = n.neighbors.find(v => v.id === link.source);
                                if (neighbor) {
                                    neighbor.pgen = val;

                                    // --- NEW: manual edit activates override ---
                                    neighbor.pgenOverride = true;
                                }
                            }
                        });

                        actualizarTablaAristas(); // refresh table
                    };

                    pgenCell.appendChild(pgenInput);
                    fila.appendChild(pgenCell);

                    tbody.appendChild(fila);
                });
            }


            draw();
        };

        //-----------------------------------------SIMULACI√ìN------------

        const nombres_nodos = nodes.map(n => n.id).join(" ");
        fetch(`/crear_nodos_simulaqron?nodos=${nombres_nodos}`);

        function initSimulation() {
            const modo = document.getElementById("modo").value;
            const num_PairsEPR = document.getElementById("num_PairsEPR").value;
            console.log("Iniciando simulaci√≥n √∫nica");

            const pswap_nodes = nodes.map(n => `${n.name}:${n.swap}`).join(",");

            // Distances in format source:target:value
            const distancias = links.map(l => `${l.source}:${l.target}:${l.distanciaKm}`).join(",");

            // pgen values in format source:target:value
            const pgen_links = links.map(l => `${l.source}:${l.pgen}`).join(",");


            const time_mode = document.getElementById("time_mode").value;
            const canal_cuantico = getQuantum_channel();

            fetch(`/simular?modo=${modo}&num_PairsEPR=${num_PairsEPR}&pgen_nodos=${pgen_links}&distancias=${distancias}&pswap_nodes=${pswap_nodes}&time_mode=${time_mode}&canal_cuantico=${encodeURIComponent(canal_cuantico)}`)
                .then(response => response.json())
                .then(data => {
                    document.getElementById("result").innerHTML =
                        "<strong>Resultado de la medici√≥n en Bob:</strong><br>" + data.result;
                    document.getElementById("state").innerHTML =
                        "<strong>Estado:</strong> Informaci√≥n enviada correctamente desde Alice a Bob.";
                    document.getElementById("counter").innerHTML =
                        "<strong>Simulaciones realizadas:</strong> " + data.counter;
                    actualizarTabla(data.historial);
                    document.getElementById("loading").style.display = "none";
                    document.getElementById("counter2").innerText = "";
                });
        }


        function mostrarResultado(data) {
            document.getElementById("result").innerHTML =
                "<strong>Resultado de la medici√≥n en Bob:</strong><br>" + data.result;
            document.getElementById("state").innerHTML =
                "<strong>Estado:</strong> Informaci√≥n enviada correctamente desde Alice a Bob.";
            document.getElementById("counter").innerHTML =
                "<strong>Simulaciones realizadas:</strong> " + data.counter;
            actualizarTabla(data.historial);
            document.getElementById("loading").style.display = "none";
        }

        const historial = JSON.parse('{{ historial|tojson|safe }}');
        document.addEventListener("DOMContentLoaded", () => {
            cargarHistorial({historial});
        });
        // variable global para guardar el id del intervalo
        let eprIntervalId = null;
        // Global map that persists across calls
        const eprMap = new Map();
        function cargarHistorial(historial) {
            const tabla = document.getElementById("results-table");
            const thead = tabla.querySelector("thead");
            const tbody = tabla.querySelector("tbody");

            // Reset table header and body
            thead.innerHTML = "";
            tbody.innerHTML = "";

            // Stop any active EPR interval before deciding what to show
            if (eprIntervalId !== null) {
                clearInterval(eprIntervalId);
                eprIntervalId = null;
            }

            // Check if any entry contains "pre" in its id
            const containsPre = Array.isArray(history) && history.some(line => line.includes("pre"));

            if (containsPre) {
                // Show reduced "Results" table
                thead.innerHTML = `
                    <tr>
                        <th>ID</th>
                        <th>Estado</th>
                    </tr>
                `;
                actualizarTabla(historial);
            } else {
                // Show full "EPR Pairs" table
                thead.innerHTML = `
                    <tr>
                        <th>ID</th>
                        <th>State</th>
                        <th>link</th>
                        <th>w_gen</th>
                        <th>w_out</th>
                        <th>t_gen</th>
                        <th>t_recv</th>
                        <th>t_diff</th>
                        <th>Medici√≥n</th>
                        <th>Purificado de</th>
                        <th>t_pur</th>
                    </tr>
                `;
                

                const loadEPR = () => {
                    fetch("/master/pairEPR")
                        .then(res => res.json())
                        .then(data => {
                            for (const [key, list] of Object.entries(data.MASTER_PAR_EPR || {})) {
                                list.forEach(epr => {
                                    if (eprMap.has(epr.id)) {
                                        // Update existing entry without changing its position
                                        const existing = eprMap.get(epr.id);
                                        eprMap.set(epr.id, { ...existing, ...epr, link: key });
                                    } else {
                                        // New entry ‚Üí appended at the end
                                        eprMap.set(epr.id, { ...epr, link: key });
                                    }
                                });
                            }
                            // Convert to array in insertion order
                            const orderedList = Array.from(eprMap.values());
                            updateEPRTable(orderedList);
                        })
                        .catch(err => console.error("Error loading EPR:", err));
                };


                loadEPR();
                if (eprIntervalId === null) {
                    eprIntervalId = setInterval(loadEPR, 2000);
                }
            }
        }


        function actualizarTabla(historial) {
            const tbody = document.querySelector("#results-table tbody");
            tbody.innerHTML = "";

            if (Array.isArray(historial) && historial.length > 0) {
                historial.forEach(linea => {
                    const fila = document.createElement("tr");
                    const partes = linea.split(":");
                    fila.innerHTML = `
                        <td>${partes[0].trim()}</td>
                        <td>${partes[1]?.trim() ?? ""}</td>
                    `;
                    tbody.appendChild(fila);
                });
            } else {
                // opcional: mostrar mensaje cuando no hay historial
                const fila = document.createElement("tr");
                fila.innerHTML = `<td colspan="2">Sin operaciones todav√≠a</td>`;
                tbody.appendChild(fila);
            }
        }
        let ultimoHistorialEPR = null;

        function formatNumber(val) {
            return (typeof val === "number") ? val.toFixed(5) : (val ?? "");
        }

        function updateEPRTable(historial) {
            // si hay al menos un elemento, actualizamos el timestamp del √∫ltimo
            console.log(historial)
            if(historial == []){
                return
            }

            const newJSON = JSON.stringify(historial);
            if (ultimoHistorialEPR === newJSON) return;
            ultimoHistorialEPR = newJSON;

            const tbody = document.querySelector("#results-table tbody");
            tbody.innerHTML = "";


            historial.forEach(epr => {
                const fila = document.createElement("tr");
                if (epr.purificado_de === "purified") fila.classList.add("fila-purificada");
                
                fila.innerHTML = `
                    <td>${epr.id}</td>
                    <td>${epr.state}</td>
                    <td>${epr.link}</td>
                    <td>${formatNumber(epr.w_gen) ?? ""}</td>
                    <td>${formatNumber(epr.w_out)}</td>
                    <td>${epr.t_gen ?? ""}</td>
                    <td>${epr.t_recv ?? ""}</td>
                    <td>${formatNumber(epr.t_diff)}</td>
                    <td>${epr.medicion ?? ""}</td>
                    <td>${epr.state === "purified" ? (epr.purificado_de?.join(", ") ?? "") : ""}</td>
                    <td>${epr.state === "purified" ? (epr.t_pur ?? "") : ""}</td>

                `;
                tbody.appendChild(fila);
            });
        }



        

        function cleanHistory() {
            // recorrer todos los puertos del 5000 al 5010, saltando el 5001
            (async () => {
                for (let puerto = 5000; puerto <= 5010; puerto++) {
                    if (puerto === 5001) continue; // saltar el 5001

                    try {
                        const res = await fetch(`http://localhost:${puerto}/history`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ pairEPR: [] })
                        });

                        if (!res.ok) {
                            console.warn(`Node in port ${puerto} did not respond correctly `);
                            break; // parar el bucle si no responde bien
                        }
                    } catch (err) {
                        console.warn(`Could not connect to the node on port ${puerto}:`, err);
                        break; // parar el bucle si no conecta
                    }
                }

                // limpiar historial en el master
                fetch("/limpiar_historial")
                    .then(response => response.json())
                    .then(data => {
                        document.getElementById("result").innerHTML =
                            "<strong>Resultado de la medici√≥n en Bob:</strong><br>Historial borrado.";
                        document.getElementById("state").innerHTML =
                            "<strong>Estado:</strong> Historial limpiado correctamente.";
                        document.getElementById("counter").innerHTML =
                            "<strong>Simulaciones realizadas:</strong> 0";
                        eprMap.clear();
                        ultimoHistorialEPR = null;
                        actualizarTabla([]);
                        updateEPRTable([]);
                    })
                    .catch(err => console.error("Error limpiando historial master:", err));
            })();
        }
        function downloadHistoryAsTXT() {
            let text = "";

            const rows = document.querySelectorAll("#results-table  tbody tr");

            rows.forEach(row => {
                const cols = row.querySelectorAll("td");
                let line = [];
                cols.forEach(col => line.push(col.innerText.trim()));
                text += line.join("\t") + "\n";
            });

            // Send the text to the backend
            fetch("/master/save_txt", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ content: text })
            })
            .then(r => r.json())
            .then(data => console.log("TXT saved on server:", data))
            .catch(err => console.error("Error saving TXT:", err));
            // 2. Clear UI
            actualizarTabla([]);
            updateEPRTable([]);
            eprMap.clear();
            ultimoHistorialEPR = null;
            console.log("Saving history");
        }

        const evtSource = new EventSource("/updates/stream");

        evtSource.onmessage = function(event) {
            if (event.data === "history_cleared") {
                console.log("Master cleared history!");
                // 1. Save the table as TXT
                downloadHistoryAsTXT();
            }
        };



        document.getElementById("num_PairsEPR").addEventListener("change", () => {
            const newModo = document.getElementById("num_PairsEPR").value;
            if (newModo !== modoAnterior) {
                fetch("/limpieza_docs")
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === "ok") {
                            document.getElementById("state").innerHTML =
                                "<strong>Estado:</strong> Qubits limpiados al cambiar de num_PairsEPR generados.";
                            console.log("Qubits limpiados correctamente.");
                        } else {
                            document.getElementById("state").innerHTML =
                                "<strong>Estado:</strong> Error al limpiar qubits.";
                            console.warn("Error al limpiar qubits.");
                        }
                        modoAnterior = newModo;
                    });
            }
        });

        function getQuantum_channel() {
            const tipo = document.getElementById("channel_type").value;
            if (tipo === "number") {
                return document.getElementById("quantum_channel").value;
            } else {
                const matrix = [];
                for (let i = 0; i < 4; i++) {
                    const row = [];
                    for (let j = 0; j < 4; j++) {
                        row.push(parseFloat(document.getElementById(`m${i}${j}`).value));
                    }
                    matrix.push(row);
                }
                return JSON.stringify(matrix);
            }
        }


    </script>
</body>
</html>
