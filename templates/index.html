<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Simulaci√≥n Cu√°ntica</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_index.css') }}?v=9">
</head>
<body>
    <div class="container-flex">
            <!-- Columna izquierda: par√°metros f√≠sicos -->
            <div class="columna-izquierda" style="position: relative;">
                <h2>Editor de Mapa Cu√°ntico</h2>

                <div class="controles">
                    <button id="modoNodo" class="boton">üñåÔ∏è Crear Nodos</button>
                    <button id="modoArista" class="boton">üîó Crear Aristas</button>
                    <label>pgen:</label>
                    <input type="number" id="pgen" min="0" max="1" step="0.01" value="0.8">
                    <button id="zoomIn" class="boton">‚ûï</button>
                    <button id="zoomOut" class="boton">‚ûñ</button>
                    <button id="resetView" class="boton">üìç</button>
                    <button id="btnActualizarNodos">Actualizar nodos</button>
                </div>

                <input type="number" id="pgenInput" class="pgen-input" />
                <input type="text" id="nameInput" class="name-input" />

                <div id="mapa-wrapper" style="position: relative;">
                    <svg id="canvas"></svg>
                    <button id="btnrecibirInfo" style="
                        position: absolute;
                        top: 20px;
                        right: 20px;
                        z-index: 10;
                        padding: 6px 12px;
                        background-color: #4CAF50;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Actualizar info</button>
                </div>


                <h3>Par√°metros f√≠sicos</h3>
                <div style="display: flex; align-items: flex-start; gap: 40px;">
                    <div>
                        <label for="pswap">pswap (0.0 - 1.0):</label>
                        <input type="number" id="pswapInput" name="pswap" min="0" max="1" step="0.01" value="0.9">
                    </div>

                    <div>
                        <label for="tipo_canal">Tipo de canal cu√°ntico:</label>
                        <select id="tipo_canal" onchange="toggleCanalInput()">
                            <option value="numero">N√∫mero (0‚Äì1)</option>
                            <option value="matriz">Matriz 4x4</option>
                        </select>

                        <!-- Input num√©rico -->
                        <div id="canal_numero">
                            <label for="canal_cuantico">Valor:</label>
                            <input type="number" id="canal_cuantico" name="canal_cuantico" min="0" max="1" step="0.01" value="1.0">
                        </div>

                        <!-- Matriz 4x4 -->
                        <div id="canal_matriz" style="display:none; margin-top:5px;">
                            <label>Canal cu√°ntico (matriz 4x4):</label>
                            <table style="border-collapse: collapse; margin-top: 5px;">
                            <tbody>
                                <tr>
                                <td><input type="number" step="0.01" id="m00" value="1.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m01" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m02" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m03" value="0.0" class="matrix-input"></td>
                                </tr>
                                <tr>
                                <td><input type="number" step="0.01" id="m10" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m11" value="1.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m12" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m13" value="0.0" class="matrix-input"></td>
                                </tr>
                                <tr>
                                <td><input type="number" step="0.01" id="m20" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m21" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m22" value="1.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m23" value="0.0" class="matrix-input"></td>
                                </tr>
                                <tr>
                                <td><input type="number" step="0.01" id="m30" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m31" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m32" value="0.0" class="matrix-input"></td>
                                <td><input type="number" step="0.01" id="m33" value="1.0" class="matrix-input"></td>
                                </tr>
                            </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                <br><br>
                <h3>Nodos</h3>
                <table id="tabla-nodos">
                    <thead>
                        <tr><th>ID</th>
                            <th>Nombre</th>
                            <th>Roles</th>
                            <th>pgen</th>
                            <th>pswap</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>

                <h3>Aristas</h3>
                <table id="tabla-aristas">
                    <thead>
                        <tr><th>Origen</th><th>Destino</th><th>Distancia (km)</th></tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button id="mostrarTopologia">Mostrar Topolog√≠a</button>
                <div id="topologiaTexto" style="white-space: pre-line; margin-top:10px;"></div>
            </div>


            <!-- Columna central: simulaci√≥n -->
            <div class="columna-centro">
                <div id="simulacion-header">
                    <h1>Simulaci√≥n Cu√°ntica</h1>
                    <p>Este experimento simula el env√≠o de <strong>2 qubits EPR</strong> desde Alice a Bob, con opci√≥n de entrelazamiento puro o con ruido (estado de Werner usando un nodo Repeater).</p>

                    <div class="resultado" id="resultado">
                        <strong>Resultado de la medici√≥n en Bob:</strong><br>
                        {{ resultado }}
                    </div>

                    <div class="estado" id="estado">
                        <strong>Estado:</strong> Esperando simulaci√≥n...
                    </div>

                    <div class="contador" id="contador">
                        <strong>Simulaciones realizadas:</strong> {{ contador }}
                    </div>

                    <div id="loading">Ejecutando simulaci√≥n... por favor espera.</div>
                    <div id="cuenta"></div>

                    <div style="margin-top: 1em;">
                        <label for="modo">Modo de env√≠o:</label>
                        <select id="modo">
                            <option value="puro">Entrelazamiento puro (Alice ‚Üí Bob)</option>
                            <option value="werner">Entrelazamiento con ruido (Alice ‚Üí Bob)</option>
                            <option value="swap">Entanglement Swap (Alice ‚Üí Charlie ‚Üê‚Üí Bob)</option>
                        </select>
                    </div>
                    <div style="margin-top: 1em; display: flex; align-items: center; gap: 1em;">
                        <div>
                            <label for="num_ParesEPR">N√∫mero de pares generados:</label><br>
                            <input type="number" id="num_ParesEPR" name="num_ParesEPR" min="1" max="10" value="2">
                        </div>

                        <div>
                            <label for="modo_tiempo">Generaci√≥n:</label><br>
                            <select id="modo_tiempo" name="modo_tiempo">
                                <option value="secuencial">Secuencial</option>
                                <option value="simultaneo">Simult√°neo</option>
                            </select>
                            <div id="decoherenciaInfo" style="margin-top: 0.5em; color: #555; display: none;">
                                En modo <strong>simult√°neo</strong>, el tiempo de decoherencia de los pares EPR puede diferir debido a la computaci√≥n paralela.
                            </div>
                        </div>
                    </div>


                    <button class="boton" onclick="iniciarSimulacion()">Iniciar Simulaci√≥n</button>
                </div>    
                 
                <!-- Secci√≥n de operaciones m√°s peque√±a -->
                <div class="columna-operaciones">
                    <h3>√ìrdenes Cu√°nticas</h3>
                        <!-- Paleta de bloques disponibles -->
                        <div id="paleta" class="paleta">
                            <!-- Bloques fijos -->
                            <div class="block op-doble" draggable="true" data-op="epr">‚öõÔ∏è Entanglement</div>
                            <div class="block op-doble" draggable="true" data-op="swap">‚öõÔ∏è Swapping</div>
                            <div class="block op-simple" draggable="true" data-op="pur">üß™ Purificaci√≥n</div>
                        </div>

                    <!-- Workspace horizontal -->
                    <h4>Secuencia de √≥rdenes
                        <button id="limpiar-workspace" class="boton">Limpiar Workspace</button>
                        <!-- Zona de eliminaci√≥n de bloques -->
                        <div id="marco-papelera" class="marco-papelera">
                            üóëÔ∏è
                        </div>
                    </h4>
                    <div id="workspace" class="workspace">
                        <!-- Aqu√≠ se soltar√°n los bloques -->
                    </div>
                    <button class="boton" onclick="mostrarOrdenes()">Exportar √ìrdenes</button>
                    <pre id="ordenesTexto"></pre>
                </div>
            </div>
            <!-- Columna derecha: historial -->
            <div class="columna-derecha">
                <h2>Historial</h2>
                <select id="modoHistorial" onchange="cargarHistorial()">
                    <option value="resultados">Resultados</option>
                    <option value="epr">Pares EPR</option>
                </select>
                <table id="tabla-resultados">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Detalle</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button class="boton" onclick="limpiarHistorial()">Limpiar historial</button>
            </div>
    </div>
    <script>
        // --- DRAG DESDE LA PALETA ---
        document.querySelectorAll(".paleta .block").forEach(block => {
            block.addEventListener("dragstart", e => {
                e.dataTransfer.setData("text", block.textContent);
                e.dataTransfer.setData("op", block.dataset.op);
                e.dataTransfer.setData("src", block.dataset.src || "");
                e.dataTransfer.setData("dst", block.dataset.dst || "");
                e.dataTransfer.setData("helper", block.dataset.helper || "");
                e.dataTransfer.setData("class", block.className);
                e.dataTransfer.setData("width", block.offsetWidth);
            });
        });

        // --- WORKSPACE ---
        const workspace = document.getElementById("workspace");
        const limpiarBtn = document.getElementById("limpiar-workspace");

        // Historial global de EPR: mantiene todos los pares aunque los nodos se oculten
        let eprHistoryGlobal = [];

        limpiarBtn.addEventListener("click", () => {
            eprHistoryGlobal = [];
            workspace.innerHTML = ""; // Borra todo
        });

        // --- Drag interno del workspace ---
        workspace.addEventListener("dragstart", e => {
            if (e.target.classList.contains("block")) {
                e.target.classList.add("dragging");
                e.dataTransfer.setData("text/plain", null); // para Firefox
            }
        });

        workspace.addEventListener("dragend", e => {
            e.target.classList.remove("dragging");
        });

        workspace.addEventListener("dragover", e => {
            e.preventDefault();
            const dragging = workspace.querySelector(".dragging");
            if (!dragging) return;

            const afterElement = getDragAfterElement(workspace, e.clientX);
            if (afterElement == null) {
                workspace.appendChild(dragging);
            } else {
                workspace.insertBefore(dragging, afterElement);
            }
        });

        function getDragAfterElement(container, x) {
            const draggableElements = [...container.querySelectorAll(".block:not(.dragging)")];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = x - box.left - box.width / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // --- Drop desde paleta ---
        workspace.addEventListener("drop", e => {
            e.preventDefault();

            const newBlock = document.createElement("div");
            newBlock.className = e.dataTransfer.getData("class");
            newBlock.dataset.op = e.dataTransfer.getData("op");
            newBlock.draggable = true;
            const width = parseInt(e.dataTransfer.getData("width"), 10);
            newBlock.style.width = width + "px";

            if (newBlock.dataset.op === "node") {
                newBlock.dataset.src = e.dataTransfer.getData("src");
                newBlock.textContent = newBlock.dataset.src;
            } else {
                newBlock.textContent = newBlock.dataset.op.toUpperCase();
            }

            workspace.appendChild(newBlock);

            actualizarBloques();
        });
        const marcoPapelera = document.getElementById("marco-papelera");

        // Permitir drop
        marcoPapelera.addEventListener("dragover", e => {
            e.preventDefault();
            marcoPapelera.classList.add("dragover");
        });

        // Borrar bloque al soltar sobre la papelera
        marcoPapelera.addEventListener("drop", e => {
            e.preventDefault();
            const dragging = workspace.querySelector(".dragging");

            if (dragging) {
                const op = dragging.dataset.op;
                if (op === "epr") {
                    const src = dragging.dataset.src;
                    const dst = dragging.dataset.dst;

                    if (src && dst) {
                        eliminarUnaEpr(src, dst);
                        console.log("EPR eliminado:", { src, dst });
                    }

                }else if (op === "pur") {
                    if (dragging.dataset.paresUsados) {
                        const usados = JSON.parse(dragging.dataset.paresUsados);

                        // Restaurar SOLO el primer EPR consumido (el que PUR realmente elimina)
                        const e1 = usados[0];

                        // Asegurar existencia de listas
                        if (!eprHistoryGlobal[e1.src]) eprHistoryGlobal[e1.src] = [];
                        if (!eprHistoryGlobal[e1.dst]) eprHistoryGlobal[e1.dst] = [];

                        // Restaurar 1 copia en cada nodo
                        eprHistoryGlobal[e1.src].push(e1);
                        eprHistoryGlobal[e1.dst].push(e1);

                        console.log("PUR eliminada ‚Üí restaurado 1 EPR:", e1);
                        console.log("Historial global tras restaurar PUR:", eprHistoryGlobal);
                    }
                } else if (op === "swap") {
                    const id1 = dragging.dataset.src;
                    const id2 = dragging.dataset.dst;
                    const helper = dragging.dataset.helper;

                    if (helper && id1) {
                        eliminarUnaEpr(helper, id1);
                        console.log("SWAP elimin√≥ EPR helper-node1:", helper, id1);
                    }
                    if (helper && id2) {
                        eliminarUnaEpr(helper, id2);
                        console.log("SWAP elimin√≥ EPR helper-node2:", helper, id2);
                    }

                }

                dragging.remove();
                actualizarBloques();

                console.log("Historial global tras borrar bloque:", eprHistoryGlobal);
            }

            marcoPapelera.classList.remove("dragover");
        });
        function eliminarUnaEpr(src, dst) {
            if (eprHistoryGlobal[src]) {
                const i = eprHistoryGlobal[src].findIndex(
                    e => e.src === src && e.dst === dst
                );
                if (i !== -1) eprHistoryGlobal[src].splice(i, 1);
            }

            if (eprHistoryGlobal[dst]) {
                const j = eprHistoryGlobal[dst].findIndex(
                    e => e.src === src && e.dst === dst
                );
                if (j !== -1) eprHistoryGlobal[dst].splice(j, 1);
            }
        }


        // Quitar efecto visual al salir
        marcoPapelera.addEventListener("dragleave", e => {
            marcoPapelera.classList.remove("dragover");
        });

        function actualizarBloques() {
            const blocks = Array.from(workspace.querySelectorAll(".block"));
            const actualizarInfoBtn = 

            // Inicializar historial para cada nodo
            blocks.forEach(b => {
                if (b.dataset.op === "node") {
                    if (!eprHistoryGlobal[b.dataset.src]) eprHistoryGlobal[b.dataset.src] = [];
                }
            });

            blocks.forEach((b, idx) => {
                if (b.dataset.finalizado) return;

                if (b.dataset.op === "epr") {
                    // Buscar nodos alrededor, sin importar si est√°n visibles
                    const prevNode = blocks.slice(0, idx).reverse().find(bb => bb.dataset.op === "node");
                    const nextNode = blocks.slice(idx + 1).find(bb => bb.dataset.op === "node");

                    if (prevNode && nextNode) {
                        b.dataset.src = prevNode.dataset.src;
                        b.dataset.dst = nextNode.dataset.src;
                        b.textContent = `${prevNode.dataset.src} ‚Üí ${nextNode.dataset.src}`;
                        b.dataset.finalizado = true;

                        // Guardar EPR en historial global
                        const nuevoEpr = { src: prevNode.dataset.src, dst: nextNode.dataset.src };

                        eprHistoryGlobal[prevNode.dataset.src].push(nuevoEpr);
                        eprHistoryGlobal[nextNode.dataset.src].push(nuevoEpr);

                        console.log("EPR agregado:", nuevoEpr);
                        console.log("Historial global:", eprHistoryGlobal);


                        // Ocultar nodos visualmente, pero mantener historial
                        prevNode.style.display = "none";
                        nextNode.style.display = "none";
                    } else {
                        b.textContent = "‚öõÔ∏è EPR üö´";
                    }

                }else if (b.dataset.op === "pur") {
                    let posiblesCandidatos = [];

                    for (let nodo in eprHistoryGlobal) {
                        const eprs = eprHistoryGlobal[nodo] || [];
                        
                        // Solo EPR donde este nodo es el que los cre√≥ (src)
                        const creados = eprs.filter(e => e.src === nodo);

                        const paresContados = {};
                        creados.forEach(e => {
                            const key = [e.src, e.dst].sort().join("-");
                            paresContados[key] = (paresContados[key] || 0) + 1;
                        });

                        for (let k in paresContados) {
                            if (paresContados[k] >= 2) {
                                const paresUsar = creados.filter(e => [e.src, e.dst].sort().join("-") === k).slice(0, 2);
                                posiblesCandidatos.push({ nodo, paresUsar });
                                break;
                            }
                        }
                    }

                    if (posiblesCandidatos.length === 0) {
                        b.textContent = "üß™ Purificaci√≥n üö´";
                    } else {
                        // Crear selector desplegable con estilo similar a bloques
                        const select = document.createElement("select");
                        select.style.fontSize = "0.85em";
                        select.style.padding = "3px 6px";
                        select.style.borderRadius = "4px";
                        select.style.border = "1px solid #aaa";
                        select.style.background = "#fff";
                        select.style.cursor = "pointer";
                        select.style.marginLeft = "5px";

                        const defaultOption = document.createElement("option");
                        defaultOption.textContent = "Select a node";
                        defaultOption.disabled = true;
                        defaultOption.selected = true;
                        select.appendChild(defaultOption);

                        posiblesCandidatos.forEach(candidato => {
                            const option = document.createElement("option");
                            option.value = candidato.nodo;
                            option.textContent = candidato.nodo;
                            select.appendChild(option);
                        });

                        b.textContent = "üß™ Purificar: ";
                        b.appendChild(select);

                        select.addEventListener("change", () => {
                            const nodoSeleccionado = select.value;
                            const elegido = posiblesCandidatos.find(c => c.nodo === nodoSeleccionado);
                            const { nodo, paresUsar } = elegido;

                            // Asignar datos al bloque
                            b.dataset.src = nodo;
                            b.dataset.finalizado = true;
                            b.dataset.paresUsados = JSON.stringify(paresUsar);
                            b.textContent = `üß™ ${nodo}`;

                            // Eliminar 1 EPR consumido en ambos nodos
                            const e1 = paresUsar[0];
                            eliminarUnaEpr(e1.src, e1.dst);

                            console.log("üß™ PUR aplicada:", elegido);
                            console.log("Historial global tras PUR:", eprHistoryGlobal);

                            // Quitar selector tras seleccionar
                            select.remove();
                        });
                    }
                }
                else if (b.dataset.op === "swap") {
                    // SWAP: usar nodos aunque est√©n ocultos, validar con historial
                    const helperNode = blocks.slice(0, idx).reverse().find(bb => bb.dataset.op === "node");
                    const nextTwoNodes = blocks.slice(idx + 1).filter(bb => bb.dataset.op === "node").slice(0, 2);

                    if (helperNode && nextTwoNodes.length === 2) {
                        const [n1, n2] = nextTwoNodes;
                        b.dataset.src = n1.dataset.src;
                        b.dataset.dst = n2.dataset.src;
                        b.dataset.helper = helperNode.dataset.src;

                        console.log("=== SWAP DEBUG ===");
                        console.log("Helper node:", helperNode.dataset.src);
                        console.log("Target nodes:", n1.dataset.src, n2.dataset.src);
                        console.log("Historial global del helper:", eprHistoryGlobal[helperNode.dataset.src]);

                        // Validar que el helper tiene EPR previos con ambos nodos
                        const valid1 = eprHistoryGlobal[helperNode.dataset.src].some(e =>
                            [e.src, e.dst].sort().join("-") === [helperNode.dataset.src, n1.dataset.src].sort().join("-")
                        );

                        const valid2 = eprHistoryGlobal[helperNode.dataset.src].some(e =>
                            [e.src, e.dst].sort().join("-") === [helperNode.dataset.src, n2.dataset.src].sort().join("-")
                        );

                        console.log("Resultados validaci√≥n swap:", valid1, valid2);
                        console.log("==================");

                        if (valid1 && valid2) {
                            b.textContent = `${n1.dataset.src.charAt(0)}<=>${n2.dataset.src.charAt(0)}(${helperNode.dataset.src.charAt(0)})`;
                            b.dataset.finalizado = true;

                            // Ocultar nodos visualmente
                            helperNode.style.display = "none";
                            n1.style.display = "none";
                            n2.style.display = "none";
                        } else {
                            b.textContent = "‚öõÔ∏è Swap üö´";
                        }
                    } else {
                        b.textContent = "‚öõÔ∏è Swap üö´";
                    }
                }
            });
        }
        function generarIdUnico() {
            return Math.random().toString(36).substr(2, 9); 
        }


       // Exportar √≥rdenes usando el mismo historial
        function mostrarOrdenes() {
            const blocks = workspace.querySelectorAll(".block");
            const orders = [];
            const eprHistory = [];
            const ordersPorNodo = {}; // objeto donde agrupamos √≥rdenes por nodo


            // Construir un mapeo name -> id
            const nameToId = {};
            nodes.forEach(n => { 
                nameToId[n.name] = n.id;
            });

            blocks.forEach((b, i) => {
                if (b.style.display === "none") return; // ignorar nodos ocultos

                const op = b.dataset.op;

                if (op === "epr") {
                    const srcName = b.dataset.src || "???";
                    const dstName = b.dataset.dst || "???";

                    if (!srcName || !dstName) {
                        orders.push(`ERROR: Bloque EPR en posici√≥n ${i} sin src o dst`);
                        return;
                    }

                    orders.push(`ENTANGLEMENT: ${srcName} crea EPR con ${dstName} [pos ${i}]`);
                    eprHistory.push({ src: srcName, dst: dstName });

                    // IDs para enviar al backend
                    const srcId = nameToId[srcName];
                    const dstId = nameToId[dstName];

                    // generar un √∫nico id para ambos
                    const eprId = generarIdUnico();

                    if (!ordersPorNodo[srcId]) ordersPorNodo[srcId] = [];
                    ordersPorNodo[srcId].push({ id: eprId, accion: "genera EPR", destino: dstId });

                    if (!ordersPorNodo[dstId]) ordersPorNodo[dstId] = [];
                    ordersPorNodo[dstId].push({ id: eprId, accion: "recibe EPR", origen: srcId });

                } else if (op === "pur") {
                    const srcName = b.dataset.src;
                    if (!srcName) {
                        orders.push(`ERROR: Bloque PUR en posici√≥n ${i} sin nodo asignado`);
                        return;
                    }

                    const eprCount = eprHistory.filter(e => e.src === srcName || e.dst === srcName).length;
                    if (eprCount < 2) {
                        orders.push(`ERROR: ${srcName} no tiene suficientes EPR previos para purificar [pos ${i}]`);
                    } else {
                        orders.push(`PURIFICACI√ìN: ${srcName} purifica dos EPR previos [pos ${i}]`);
                        const srcId = nameToId[srcName];
                        const purId = generarIdUnico();
                        if (!ordersPorNodo[srcId]) ordersPorNodo[srcId] = [];
                        ordersPorNodo[srcId].push({ id: purId, accion: "purifica", detalle: "dos EPR previos" });
                    }

                }else if (op === "swap") {
                    const id1Name = b.dataset.src;
                    const id2Name = b.dataset.dst;
                    const helperName = b.dataset.helper;

                    if (!id1Name || !id2Name || !helperName) {
                        orders.push(`ERROR: Bloque SWAP en posici√≥n ${i} incompleto (falta src, dst o helper)`);
                        return;
                    }

                    const valid1 = eprHistory.some(e => (e.src === id1Name && e.dst === helperName) || (e.src === helperName && e.dst === id1Name));
                    const valid2 = eprHistory.some(e => (e.src === id2Name && e.dst === helperName) || (e.src === helperName && e.dst === id2Name));

                    if (!valid1 || !valid2) {
                        orders.push(`ERROR: ${helperName} no tiene EPR previos con ${id1Name} y ${id2Name} para SWAP [pos ${i}]`);
                    } else {
                        orders.push(`SWAP: ${helperName} hace entanglement swapping entre ${id1Name} y ${id2Name} [pos ${i}]`);

                        const helperId = nameToId[helperName];
                        const id1Id = nameToId[id1Name];
                        const id2Id = nameToId[id2Name];
                        const swapId = generarIdUnico();
                        // Acci√≥n para el helper
                        if (!ordersPorNodo[helperId]) ordersPorNodo[helperId] = [];
                        ordersPorNodo[helperId].push({ id: swapId, accion: "swap", con: [id1Id, id2Id] });

                        // Notificar a id1 y id2 que reciben SWAP
                        if (!ordersPorNodo[id1Id]) ordersPorNodo[id1Id] = [];
                        ordersPorNodo[id1Id].push({ 
                            id: swapId, 
                            accion: "swap recibido", 
                            con: [id2Id],          // con qui√©n se hace el swap
                            gracias_a: helperId    // gracias a qui√©n se realiz√≥
                        });

                        if (!ordersPorNodo[id2Id]) ordersPorNodo[id2Id] = [];
                        ordersPorNodo[id1Id].push({ 
                            id: swapId, 
                            accion: "swap recibido", 
                            con: [id1Id],          // con qui√©n se hace el swap
                            gracias_a: helperId    // gracias a qui√©n se realiz√≥
                        });
                    }


                } else if (op === "node") {
                    orders.push(`NODE: ${b.dataset.src} [pos ${i}]`);
                } else {
                    orders.push(`ERROR: Operaci√≥n desconocida "${op}" [pos ${i}]`);
                }
            });

            // Mostrar en pantalla usando nombres
            document.getElementById("ordenesTexto").textContent = orders.join("\n");

            // Enviar autom√°ticamente al endpoint /mandate usando IDs
            fetch("/mandate", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(ordersPorNodo)
            })
            .then(response => response.json())
            .then(data => console.log("Instrucciones enviadas al servidor:", data))
            .catch(error => console.error("Error enviando instrucciones:", error));
        }




        function crearBloquesDinamicos(nodos) {
            const paleta = document.getElementById("paleta");

            nodos.forEach(nodo => {
                // Evitar bloques duplicados fijos (EPR y Pur)
                if (nodo.name.includes("epr") || nodo.name.includes("Pur") ||nodo.name.includes("swap")) return;
                // üîç Si ya existe un bloque con este ID, no crearlo de nuevo
                const yaExiste = paleta.querySelector(`[data-id="${nodo.id}"]`);
                if (yaExiste) return;

                const block = document.createElement("div");
                block.className = "block op-simple";
                block.draggable = true;

                // Guardamos info del nodo en dataset para an√°lisis posterior
                block.dataset.op = "node";
                block.dataset.src = nodo.name;    // nombre del nodo
                block.dataset.id = nodo.id;       // id del nodo
                block.dataset.pgen = nodo.pgen;   // probabilidad de generaci√≥n
                block.dataset.neighbors = JSON.stringify(nodo.neighbors); // vecinos en JSON
                block.dataset.parEPR = JSON.stringify(nodo.parEPR);

                // Texto del bloque = nombre del nodo
                block.textContent = nodo.name;

                // Drag & Drop
                block.addEventListener("dragstart", e => {
                    e.dataTransfer.setData("text", block.textContent);
                    e.dataTransfer.setData("op", block.dataset.op);
                    e.dataTransfer.setData("src", block.dataset.src);
                    e.dataTransfer.setData("id", block.dataset.id);
                    e.dataTransfer.setData("pgen", block.dataset.pgen);
                    e.dataTransfer.setData("neighbors", block.dataset.neighbors);
                    e.dataTransfer.setData("parEPR", block.dataset.parEPR);
                    e.dataTransfer.setData("class", block.className);
                    e.dataTransfer.setData("width", block.offsetWidth);
                });

                paleta.appendChild(block);
            });
        }
        function ajustarColumnasSegunNodos(nodo_info) {
            if (Array.isArray(nodo_info.nodes) && nodo_info.nodes.length > 0) {
                // comprobar si todos los ids terminan en "pre"
                const todosPre = nodo_info.nodes.every(n => n.id.endsWith("pre"));

                if (todosPre) {
                    // mostrar la cabecera normalmente
                    const header = document.getElementById("simulacion-header");
                    if (header) header.style.display = "block";

                    // restaurar tama√±o normal de la derecha
                    const derecha = document.querySelector(".columna-derecha");
                    if (derecha) derecha.style.flex = "1.5";
                } else {
                    // ocultar la cabecera de simulaci√≥n
                    const header = document.getElementById("simulacion-header");
                    if (header) header.style.display = "none";

                    // expandir la columna derecha
                    const derecha = document.querySelector(".columna-derecha");
                    if (derecha) derecha.style.flex = "2";
                }
            }
        }



        // Rol recibido desde Flask
        const rol = "{{ rol }}";
        let nodes = [];
        let links = [];

        if (rol === "master") {
            const nodo_info = JSON.parse('{{ nodo_info|tojson|safe }}');
            console.log("Objeto nodo_info recibido:", nodo_info);

            if (nodo_info.nodes && nodo_info.nodes.length > 0) {
                // Inicializar nodos desde el backend (ya incluye predefinidos si hace falta)
                nodes = nodo_info.nodes;
                console.log("Nodos inicializados:", nodes);

                // aplicar ajuste de columnas
                ajustarColumnasSegunNodos(nodo_info);

                nodes.forEach(nodo => {
                    if (Array.isArray(nodo.neighbors)) {
                        nodo.neighbors.forEach(vecino => {
                            const link = {
                                source: nodo.id,
                                target: vecino.id,
                                distanciaKm: vecino.distanceKm
                            };
                            links.push(link);
                        });
                    }
                });
            }
        }

        console.log("Rol actual:", rol);
        console.log("Lista final de Nodes:", nodes);
        console.log("Lista final de Links:", links);


        // Crear bloques para los nodos detectados
        document.addEventListener("DOMContentLoaded", () => {
            crearBloquesDinamicos(nodes);
        });



        document.getElementById("mostrarTopologia").addEventListener("click", () => {
            fetch("/topologia")
                .then(res => res.json())
                .then(data => {
                    let texto = "";
                    for (const nodo in data) {
                        texto += `Nodo ${nodo} conectado con: {${data[nodo].join(", ")}}\n`;
                    }
                    document.getElementById("topologiaTexto").textContent = texto;
                });
        });
    </script>

    <script>
        document.getElementById("modo_tiempo").addEventListener("change", function () {
            const info = document.getElementById("decoherenciaInfo");
            if (this.value === "simultaneo") {
                info.style.display = "block";
            } else {
                info.style.display = "none";
            }
        });
        document.getElementById("tipo_canal").addEventListener("change", function() {
            const tipo = this.value;
            document.getElementById("canal_numero").style.display = (tipo === "numero") ? "block" : "none";
            document.getElementById("canal_matriz").style.display = (tipo === "matriz") ? "block" : "none";
        });
    </script>
    <script>
        function obtenerPuertoDesdeId(id) {
            const mapa = {
                "node_alice": 5000,
                "node_bob": 5002,
                "node_charlie": 5003,
                "node_eve": 5004
                // Agrega m√°s si tienes m√°s nodos
            };
            return mapa[id];
        }
        //-----------------------------------------MAPA-----------------------------------------------
        window.onload = function () {
            const svg = document.getElementById("canvas");
            const paramInput = document.getElementById("pgenInput");
            const nameInput = document.getElementById("nameInput");
            const pgenInput = document.getElementById("pgen");
            const modoNodoBtn = document.getElementById("modoNodo");
            const modoAristaBtn = document.getElementById("modoArista");
            const zoomInBtn = document.getElementById("zoomIn");
            const zoomOutBtn = document.getElementById("zoomOut");
            const resetViewBtn = document.getElementById("resetView");
            const actualizarNodosBtn = document.getElementById("btnActualizarNodos");
            const recibirInfoBtn = document.getElementById("btnrecibirInfo")

            let modoNodo = false;
            let modoArista = false;
            let selectedNode = null, draggingNode = null, linkStart = null;
            let transform = { x: 0, y: 0, k: 1 };
            let draggingMap = false;
            let dragStart = { x: 0, y: 0 };

            // Llama al renderizado
            draw();


            modoNodoBtn.onclick = () => {
                modoNodo = !modoNodo;
                modoArista = false;
                modoNodoBtn.classList.toggle("activo", modoNodo);
                modoAristaBtn.classList.remove("activo");
            };

            modoAristaBtn.onclick = () => {
                modoArista = !modoArista;
                modoNodo = false;
                modoAristaBtn.classList.toggle("activo", modoArista);
                modoNodoBtn.classList.remove("activo");
            };

            zoomInBtn.onclick = () => {
                transform.k *= 1.1;
                draw();
            };

            zoomOutBtn.onclick = () => {
                transform.k *= 0.9;
                draw();
            };

            resetViewBtn.onclick = () => {
                transform = { x: 0, y: 0, k: 1 };
                draw();
            };
            // Recibir informaci√≥n desde el master y actualizar el mapa
            recibirInfoBtn.addEventListener("click", () => {
                fetch("/actualizar_mapa")
                    .then(res => res.json())
                    .then(data => {
                        console.log("Datos recibidos de /actualizar_mapa:", data);
                        
                        // Detectar nodos vivos
                        const nodosVivos = new Set(data.nodes.map(n => n.id));

                        // Eliminar nodos muertos del array local
                        for (let i = nodes.length - 1; i >= 0; i--) {
                            if (!nodosVivos.has(nodes[i].id)) {
                                console.log("Nodo desconectado eliminado:", nodes[i].name);
                                nodes.splice(i, 1);
                            }
                        }
                        // Merge inteligente: no machacar cambios locales si son m√°s recientes
                        data.nodes.forEach(remoteNode => {
                            const localNode = nodes.find(n => n.id === remoteNode.id);
                            if (localNode) {
                                if (!localNode.lastUpdated || localNode.lastUpdated < remoteNode.lastUpdated) {
                                    Object.assign(localNode, remoteNode);
                                } else {
                                    console.log(`Manteniendo cambios locales en nodo ${localNode.name}`);
                                }
                            } else {
                                nodes.push(remoteNode);
                            }
                        });

                        /// Recalcular links consolidando por lastUpdated
                        links.length = 0;
                        const linksDict = {};

                        nodes.forEach(nodo => {
                            const ts = nodo.lastUpdated || 0;
                            if (Array.isArray(nodo.neighbors)) {
                                nodo.neighbors.forEach(vecino => {
                                    const par = [nodo.name, vecino.name].sort().join("-");
                                    const distancia = vecino.distanceKm;

                                    if (!linksDict[par]) {
                                        linksDict[par] = { source: nodo.name, target: vecino.name, distanciaKm: distancia, lastUpdated: ts };
                                    } else {
                                        if (ts > linksDict[par].lastUpdated) {
                                            linksDict[par] = { source: nodo.name, target: vecino.name, distanciaKm: distancia, lastUpdated: ts };
                                        }
                                    }
                                });
                            }
                        });

                        // convertir a array
                        Object.values(linksDict).forEach(l => {
                            links.push({ source: l.source, target: l.target, distanciaKm: l.distanciaKm });
                        });

                        const paleta = document.getElementById("paleta");
                        paleta.querySelectorAll('[data-op="node"]').forEach(b => b.remove());
                        console.log("nodos",nodes);
                        crearBloquesDinamicos(nodes);

                        draw();
                        actualizarTablaNodos();
                        actualizarTablaAristas();
                    })
                    .catch(err => console.error("Error al recibir info de nodos:", err));
                    // Mostrar aviso al usuario
            });
            // Recibir informaci√≥n desde el master y actualizar el mapa
            recibirInfoBtn.addEventListener("click", () => {
                fetch("/actualizar_mapa")
                    .then(res => res.json())
                    .then(data => {
                        console.log("Datos recibidos de /actualizar_mapa:", data);
                        
                        // Detectar nodos vivos
                        const nodosVivos = new Set(data.nodes.map(n => n.id));

                        // Eliminar nodos muertos del array local
                        for (let i = nodes.length - 1; i >= 0; i--) {
                            if (!nodosVivos.has(nodes[i].id)) {
                                console.log("Nodo desconectado eliminado:", nodes[i].id);
                                nodes.splice(i, 1);
                            }
                        }
                        // Merge inteligente: no machacar cambios locales si son m√°s recientes
                        data.nodes.forEach(remoteNode => {
                            const localNode = nodes.find(n => n.id === remoteNode.id);
                            if (localNode) {
                                if (!localNode.lastUpdated || localNode.lastUpdated < remoteNode.lastUpdated) {
                                    Object.assign(localNode, remoteNode);
                                } else {
                                    console.log(`Manteniendo cambios locales en nodo ${localNode.id}`);
                                }
                            } else {
                                nodes.push(remoteNode);
                            }
                        });

                        /// Recalcular links consolidando por lastUpdated
                        links.length = 0;
                        const linksDict = {};

                        nodes.forEach(nodo => {
                            const ts = nodo.lastUpdated || 0;
                            if (Array.isArray(nodo.neighbors)) {
                                nodo.neighbors.forEach(vecino => {
                                    const par = [nodo.id, vecino.id].sort().join("-");
                                    const distancia = vecino.distanceKm;

                                    if (!linksDict[par]) {
                                        linksDict[par] = { source: nodo.id, target: vecino.id, distanciaKm: distancia, lastUpdated: ts };
                                    } else {
                                        if (ts > linksDict[par].lastUpdated) {
                                            linksDict[par] = { source: nodo.id, target: vecino.id, distanciaKm: distancia, lastUpdated: ts };
                                        }
                                    }
                                });
                            }
                        });

                        // convertir a array
                        Object.values(linksDict).forEach(l => {
                            links.push({ source: l.source, target: l.target, distanciaKm: l.distanciaKm });
                        });

                        const paleta = document.getElementById("paleta");
                        paleta.querySelectorAll('[data-op="node"]').forEach(b => b.remove());
                        console.log("nodos",nodes);
                        crearBloquesDinamicos(nodes);

                        draw();
                        actualizarTablaNodos();
                        actualizarTablaAristas();
                    })
                    .catch(err => console.error("Error al recibir info de nodos:", err));
            });

            // Enviar todos los cambios a cada nodo
            actualizarNodosBtn.addEventListener("click", () => {
                nodes.forEach(node => {
                    const puerto = obtenerPuertoDesdeId(node.id);
                    if (!puerto) return;
                    const vecinosSimetricos = [];
                    console.log(node)
                    nodes.forEach(other => {
                        if (other.id !== node.id) {
                            // Buscar si este nodo ya tiene a "other" como vecino
                            const esteVecino = node.neighbors.find(v => v.id === other.id);
                            // Buscar si el otro nodo ya tiene a "node" como vecino
                            const otroVecino = other.neighbors.find(v => v.id === node.id);

                            // Solo a√±adimos si alguno conoce la distancia
                            const distanciaKm = (esteVecino && esteVecino.distanceKm) ||
                                                (otroVecino && otroVecino.distanceKm);

                            if (distanciaKm !== undefined) {
                                vecinosSimetricos.push({
                                    id: other.id,
                                    distanceKm: distanciaKm
                                });
                            }
                        }
                    });

                    console.log(vecinosSimetricos)
                    fetch(`http://127.0.0.1:${puerto}/update`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            id: node.id,
                            name: node.name,
                            pgen: node.pgen,
                            pswap: node.pswap,
                            roles: node.roles,
                            neighbors: vecinosSimetricos,
                            parEPR: node.parEPR,
                            lastUpdated: Date.now() // importante: marcar timestamp
                        })
                    }).catch(err => console.error(`Error al actualizar nodo ${node.id}:`, err));
                });

                // Esperar un momento y luego refrescar el mapa completo desde master
                setTimeout(() => {
                    fetch("/actualizar_mapa")
                        .then(res => res.json())
                        .then(data => {
                            console.log("Datos recibidos de /actualizar_mapa:", data);

                            // Machacar nodes locales con lo que diga el master
                            nodes.length = 0;
                            nodes.push(...data.nodes);

                            // Recalcular links
                            links.length = 0;
                            nodes.forEach(nodo => {
                                if (Array.isArray(nodo.neighbors)) {
                                    nodo.neighbors.forEach(vecino => {
                                        links.push({
                                            source: nodo.id,
                                            target: vecino.id,
                                            distanciaKm: vecino.distanceKm
                                        });
                                    });
                                }
                            });

                            draw();
                            actualizarTablaNodos();
                            actualizarTablaAristas();
                        })
                        .catch(err => console.error("Error al actualizar mapa:", err));
                }, 1500);
            });

            function createNode(x, y) {
                const node = {
                    id: crypto.randomUUID(),          // identificador √∫nico
                    name: "Nodo_" + Date.now(),       // nombre inicial editable
                    roles: ["emisor","receptor","repeater"], // roles activos
                    x, y,
                    pgen: 0.8,
                    pswap: 0.8,
                    neighbors: []
                };
                nodes.push(node);
                draw();
                // Llamada al backend Flask para crear nodo en Simulaqron usando id
                fetch(`/crear_nodos_simulaqron?nodos=${node.id}`)
                    .then(res => res.json())
                    .then(data => {
                        console.log("Respuesta del servidor:", data);
                    })
                    .catch(err => console.error("Error al crear nodo en Simulaqron:", err));
            }


            function createLink(sourceNode, targetNode) {
                const existe = links.some(link =>
                    (link.source === sourceNode.id && link.target === targetNode.id) ||
                    (link.source === targetNode.id && link.target === sourceNode.id)
                );
                if (existe) return;

                const distanciaKm = 50;
                const length = Math.hypot(targetNode.x - sourceNode.x, targetNode.y - sourceNode.y);

                links.push({ source: sourceNode.id, target: targetNode.id, length, distanciaKm });
                draw();

                fetch("/modificar_links", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        links: [{ source: sourceNode.id, target: targetNode.id }]
                    })
                });
            }
            function draw() {
                svg.innerHTML = "";
                const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                g.setAttribute("transform", `translate(${transform.x},${transform.y}) scale(${transform.k})`);
                svg.appendChild(g);

                // Dibujar aristas
                links.forEach(link => {
                    const sourceNode = nodes.find(n => n.id === link.source);
                    const targetNode = nodes.find(n => n.id === link.target);

                    if (!sourceNode) {
                        console.warn(`Nodo no conectado a la red: ${link.source}`);
                        return;
                    }
                    if (!targetNode) {
                        console.warn(`Nodo no conectado a la red: ${link.target}`);
                        return;
                    }

                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", sourceNode.x);
                    line.setAttribute("y1", sourceNode.y);
                    line.setAttribute("x2", targetNode.x);
                    line.setAttribute("y2", targetNode.y);
                    line.setAttribute("class", "link");
                    g.appendChild(line);

                });

                // Dibujar nodos
                nodes.forEach(node => {
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", node.x);
                    circle.setAttribute("cy", node.y);
                    circle.setAttribute("r", 20);
                    circle.setAttribute("class", "node");

                    circle.addEventListener("mousedown", e => {
                        if (modoArista) {
                            if (linkStart && linkStart !== node) {
                                createLink(linkStart, node);
                                linkStart = null;
                            } else {
                                linkStart = node;
                            }
                        } else {
                            draggingNode = node;
                        }
                    });

                    g.appendChild(circle);

                    // Mostrar nombre (no id)
                    const nameLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    nameLabel.setAttribute("x", node.x);
                    nameLabel.setAttribute("y", node.y + 35);
                    nameLabel.setAttribute("class", "label");
                    nameLabel.textContent = node.name;
                    g.appendChild(nameLabel);

                    const paramLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    paramLabel.setAttribute("x", node.x);
                    paramLabel.setAttribute("y", node.y + 50);
                    paramLabel.setAttribute("class", "label");
                    paramLabel.textContent = "pgen = " + node.pgen;
                    g.appendChild(paramLabel);
                });

                actualizarTablaNodos();
                actualizarTablaAristas();
            }


        svg.addEventListener("click", e => {
            if (!modoNodo) return;
            const pt = getMousePosition(e);
            createNode(pt.x, pt.y);
        });

        svg.addEventListener("mousedown", e => {
            if (!modoNodo && !modoArista) {
                draggingMap = true;
                dragStart = { x: e.clientX, y: e.clientY };
            }
        });

        svg.addEventListener("mousemove", e => {
            if (draggingNode) {
                const pt = getMousePosition(e);
                draggingNode.x = pt.x;
                draggingNode.y = pt.y;
                draw();
            } else if (draggingMap) {
                const dx = e.clientX - dragStart.x;
                const dy = e.clientY - dragStart.y;
                transform.x += dx;
                transform.y += dy;
                dragStart = { x: e.clientX, y: e.clientY };
                draw();
            }
        });

        svg.addEventListener("mouseup", () => {
            draggingNode = null;
            draggingMap = false;
        });

        svg.addEventListener("mouseleave", () => {
            draggingNode = null;
            draggingMap = false;
        });

        paramInput.addEventListener("change", () => {
            if (selectedNode) {
                selectedNode.pgen = parseFloat(pgenInput.value);
                pgenInput.style.display = "none";
                draw();
            }
        });

        nameInput.addEventListener("change", () => {
            if (selectedNode) {
                selectedNode.name = nameInput.value;
                selectedNode.id = nameInput.value;
                nameInput.style.display = "none";
                draw();
            }
        });

        function getMousePosition(e) {
            const rect = svg.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left - transform.x) / transform.k,
                y: (e.clientY - rect.top - transform.y) / transform.k
            };
        }
        function actualizarTablaNodos() {
            const tbody = document.querySelector("#tabla-nodos tbody");
            tbody.innerHTML = "";

            nodes.forEach(node => {
                const fila = document.createElement("tr");

                // ID (solo lectura)
                const idCell = document.createElement("td");
                idCell.textContent = node.id;
                fila.appendChild(idCell);

                // Nombre (editable)
                const nameCell = document.createElement("td");
                const nameInput = document.createElement("input");
                nameInput.value = node.name;
                nameInput.onchange = () => {
                    const oldName = node.name;
                    const newName = nameInput.value;

                    // Actualizar el nombre del nodo
                    node.name = newName;
                    node.label = newName;
                    // Actualizar vecinos que lo referencian
                    nodes.forEach(n => {
                        n.neighbors.forEach(vecino => {
                            if (vecino.name === oldName) {
                                vecino.name = newName;
                            }
                        });
                    });

                    // Actualizar enlaces
                    links.forEach(link => {
                        if (link.source === oldName) link.source = newName;
                        if (link.target === oldName) link.target = newName;
                    });

                    // Enviar cambio de nombre al backend del nodo
                    const puerto = obtenerPuertoDesdeId(node.id);
                    if (puerto) {
                        fetch(`http://localhost:${puerto}/update`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ name: newName })
                        });
                    }

                    draw();
                };
                nameCell.appendChild(nameInput);
                fila.appendChild(nameCell);

                // Roles (checkboxes)
                const rolesCell = document.createElement("td");
                ["emisor", "receptor", "repeater"].forEach(role => {
                    const chk = document.createElement("input");
                    chk.type = "checkbox";
                    chk.checked = node.roles.includes(role);
                    chk.onchange = () => {
                        if (chk.checked && !node.roles.includes(role)) {
                            node.roles.push(role);
                        } else {
                            node.roles = node.roles.filter(r => r !== role);
                        }
                        draw();
                    };
                    const lbl = document.createElement("label");
                    lbl.textContent = role;
                    rolesCell.appendChild(chk);
                    rolesCell.appendChild(lbl);
                });
                fila.appendChild(rolesCell);

                // PGEN
                const pgenCell = document.createElement("td");
                const pgenInput = document.createElement("input");
                pgenInput.type = "number";
                pgenInput.step = "0.01";
                pgenInput.min = "0";
                pgenInput.max = "1";
                pgenInput.value = node.pgen;
                pgenInput.onchange = () => {
                    node.pgen = parseFloat(pgenInput.value);
                    draw();
                };
                pgenCell.appendChild(pgenInput);
                fila.appendChild(pgenCell);

                tbody.appendChild(fila);
                // Param pswap
                const pswapCell = document.createElement("td");
                const pswapInput = document.createElement("input");
                pswapInput.type = "number";
                pswapInput.step = "0.01";
                pswapInput.min = "0";
                pswapInput.max = "1";
                pswapInput.value = node.pswap || 0.9;
                pswapInput.onchange = () => {
                    node.pswap = parseFloat(pswapInput.value);
                    draw();
                };
                pswapCell.appendChild(pswapInput);
                fila.appendChild(pswapCell);

                            
            });
        }

        function actualizarTablaAristas() {
            const tbody = document.querySelector("#tabla-aristas tbody");
            tbody.innerHTML = "";

            const vistos = new Set();

            links.forEach(link => {
                // normalizar par
                const key = [link.source, link.target].sort().join("-");
                if (vistos.has(key)) return; // ya mostrado
                vistos.add(key);

                const fila = document.createElement("tr");

                const origenCell = document.createElement("td");
                origenCell.textContent = link.source;
                fila.appendChild(origenCell);

                const destinoCell = document.createElement("td");
                destinoCell.textContent = link.target;
                fila.appendChild(destinoCell);

                const distCell = document.createElement("td");
                const distInput = document.createElement("input");
                distInput.type = "number";
                distInput.value = link.distanciaKm;

                distInput.onchange = () => {
                    const nuevaDistancia = parseFloat(distInput.value);

                    // actualizar ambos links sim√©tricos
                    links.forEach(l => {
                        const par = [l.source, l.target].sort().join("-");
                        if (par === key) {
                            l.distanciaKm = nuevaDistancia;
                        }
                    });

                    // actualizar vecinos en ambos nodos
                    const origenNode = nodes.find(n => n.name === link.source);
                    if (origenNode) {
                        const vecino = origenNode.neighbors.find(v => v.name === link.target);
                        if (vecino) vecino.distanceKm = nuevaDistancia;
                    }
                    const destinoNode = nodes.find(n => n.name === link.target);
                    if (destinoNode) {
                        const vecino = destinoNode.neighbors.find(v => v.name === link.source);
                        if (vecino) vecino.distanceKm = nuevaDistancia;
                    }
                };

                distCell.appendChild(distInput);
                fila.appendChild(distCell);

                tbody.appendChild(fila);
            });
        }



        draw();
    };

        //-----------------------------------------SIMULACI√ìN------------
        function getDistancia(id) {
            const link = links.find(l => l.id === id);
            return link ? link.distanciaKm : 0;
        }

        const nombres_nodos = nodes.map(n => n.id).join(" ");
        fetch(`/crear_nodos_simulaqron?nodos=${nombres_nodos}`);

        function iniciarSimulacion() {
            const modo = document.getElementById("modo").value;
            const num_ParesEPR = document.getElementById("num_ParesEPR").value;
            console.log("Iniciando simulaci√≥n √∫nica");

            const pgen = document.getElementById("pgen").value;
            const pswap = document.getElementById("pswapInput").value;

            // Nodos con su pgen
            const pgen_nodos = nodes.map(n => `${n.name}:${n.pgen}`).join(",");

            // Distancias en formato origen:destino:valor
            const distancias = links.map(l => `${l.source}:${l.target}:${l.distanciaKm}`).join(",");

            const modo_tiempo = document.getElementById("modo_tiempo").value;
            const canal_cuantico = getCanalCuantico();

            fetch(`/simular?modo=${modo}&num_ParesEPR=${num_ParesEPR}&pgen_nodos=${pgen_nodos}&distancias=${distancias}&pswap=${pswap}&modo_tiempo=${modo_tiempo}&canal_cuantico=${encodeURIComponent(canal_cuantico)}`)
                .then(response => response.json())
                .then(data => {
                    document.getElementById("resultado").innerHTML =
                        "<strong>Resultado de la medici√≥n en Bob:</strong><br>" + data.resultado;
                    document.getElementById("estado").innerHTML =
                        "<strong>Estado:</strong> Informaci√≥n enviada correctamente desde Alice a Bob.";
                    document.getElementById("contador").innerHTML =
                        "<strong>Simulaciones realizadas:</strong> " + data.contador;
                    actualizarTabla(data.historial);
                    document.getElementById("loading").style.display = "none";
                    document.getElementById("cuenta").innerText = "";
                });
        }


        function mostrarResultado(data) {
            document.getElementById("resultado").innerHTML =
                "<strong>Resultado de la medici√≥n en Bob:</strong><br>" + data.resultado;
            document.getElementById("estado").innerHTML =
                "<strong>Estado:</strong> Informaci√≥n enviada correctamente desde Alice a Bob.";
            document.getElementById("contador").innerHTML =
                "<strong>Simulaciones realizadas:</strong> " + data.contador;
            actualizarTabla(data.historial);
            document.getElementById("loading").style.display = "none";
        }

        const historial = JSON.parse('{{ historial|tojson|safe }}');
        document.addEventListener("DOMContentLoaded", () => {
            cargarHistorial({historial});
        });
        // variable global para guardar el id del intervalo
        let eprIntervalId = null;

        function cargarHistorial(historial) {
            const modo = document.getElementById("modoHistorial").value;

            // Si ven√≠as de EPR y cambias a otro modo, parar el intervalo
            if (modo !== "epr" && eprIntervalId !== null) {
                clearInterval(eprIntervalId);
                eprIntervalId = null;
            }

            if (modo === "resultados") {
                actualizarTabla(historial);
            } else if (modo === "epr") {
                console.log("Recibo los EPRS");

                const cargarEPR = () => {
                    fetch("/master/parEPR")
                        .then(res => res.json())
                        .then(data => {
                            const mapa = new Map();
                            for (const [clave, lista] of Object.entries(data.MASTER_PAR_EPR || {})) {
                                lista.forEach(epr => {
                                    if (mapa.has(epr.id)) {
                                        // fusionar con lo que ya hab√≠a
                                        const existente = mapa.get(epr.id);
                                        mapa.set(epr.id, { ...existente, ...epr, enlace: clave });
                                    } else {
                                        mapa.set(epr.id, { ...epr, enlace: clave });
                                    }
                                });
                            }
                            actualizarTablaEPR(Array.from(mapa.values()));
                        })
                        .catch(err => console.error("Error cargando EPR:", err));
                };

                // primera carga
                cargarEPR();

                // arrancar intervalo solo si no est√° ya activo
                if (eprIntervalId === null) {
                    eprIntervalId = setInterval(cargarEPR, 2000);
                }
            }
        }

        function actualizarTabla(historial) {
            const tbody = document.querySelector("#tabla-resultados tbody");
            tbody.innerHTML = "";

            if (Array.isArray(historial) && historial.length > 0) {
                historial.forEach(linea => {
                    const fila = document.createElement("tr");
                    const partes = linea.split(":");
                    fila.innerHTML = `
                        <td>${partes[0].trim()}</td>
                        <td>${partes[1]?.trim() ?? ""}</td>
                    `;
                    tbody.appendChild(fila);
                });
            } else {
                // opcional: mostrar mensaje cuando no hay historial
                const fila = document.createElement("tr");
                fila.innerHTML = `<td colspan="2">Sin operaciones todav√≠a</td>`;
                tbody.appendChild(fila);
            }
        }


        function actualizarTablaEPR(historial) {
            console.log(historial);
            const tbody = document.querySelector("#tabla-resultados tbody");
            tbody.innerHTML = "";
            historial.forEach(epr => {
                const fila = document.createElement("tr");
                fila.innerHTML = `
                    <td>${epr.id}</td>
                    <td>Enlace: ${epr.enlace}</td>
                    <td>Estado: ${epr.estado}</td>
                    <td>Fidelidad inicial (w_gen): ${epr.w_gen}</td>
                    <td>Fidelidad final (w_out): ${epr.w_out ?? "-"}</td>
                    <td>t_gen: ${epr.t_gen}</td>
                    <td>t_recv: ${epr.t_recv ?? "-"}</td>
                    <td>t_diff: ${epr.t_diff ?? "-"}</td>
                    <td>Medici√≥n: ${epr.medicion ?? "-"}</td>
                `;
                tbody.appendChild(fila);
            });
        }
        

        function limpiarHistorial() {
            // recorrer todos los puertos del 5000 al 5010, saltando el 5001
            (async () => {
                for (let puerto = 5000; puerto <= 5010; puerto++) {
                    if (puerto === 5001) continue; // saltar el 5001

                    try {
                        const res = await fetch(`http://localhost:${puerto}/update`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ parEPR: [] })
                        });

                        if (!res.ok) {
                            console.warn(`Nodo en puerto ${puerto} no respondi√≥ correctamente`);
                            break; // parar el bucle si no responde bien
                        }
                    } catch (err) {
                        console.warn(`No se pudo conectar al nodo en puerto ${puerto}:`, err);
                        break; // parar el bucle si no conecta
                    }
                }

                // limpiar historial en el master solo si se complet√≥ el bucle
                fetch("/limpiar_historial")
                    .then(response => response.json())
                    .then(data => {
                        document.getElementById("resultado").innerHTML =
                            "<strong>Resultado de la medici√≥n en Bob:</strong><br>Historial borrado.";
                        document.getElementById("estado").innerHTML =
                            "<strong>Estado:</strong> Historial limpiado correctamente.";
                        document.getElementById("contador").innerHTML =
                            "<strong>Simulaciones realizadas:</strong> 0";
                        actualizarTabla([]);
                        actualizarTablaEPR([]);
                    })
                    .catch(err => console.error("Error limpiando historial master:", err));
            })();
        }

        document.getElementById("num_ParesEPR").addEventListener("change", () => {
            const nuevoModo = document.getElementById("num_ParesEPR").value;
            if (nuevoModo !== modoAnterior) {
                fetch("/limpieza_docs")
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === "ok") {
                            document.getElementById("estado").innerHTML =
                                "<strong>Estado:</strong> Qubits limpiados al cambiar de num_ParesEPR generados.";
                            console.log("Qubits limpiados correctamente.");
                        } else {
                            document.getElementById("estado").innerHTML =
                                "<strong>Estado:</strong> Error al limpiar qubits.";
                            console.warn("Error al limpiar qubits.");
                        }
                        modoAnterior = nuevoModo;
                    });
            }
        });

        function getCanalCuantico() {
            const tipo = document.getElementById("tipo_canal").value;
            if (tipo === "numero") {
                return document.getElementById("canal_cuantico").value;
            } else {
                const matrix = [];
                for (let i = 0; i < 4; i++) {
                    const row = [];
                    for (let j = 0; j < 4; j++) {
                        row.push(parseFloat(document.getElementById(`m${i}${j}`).value));
                    }
                    matrix.push(row);
                }
                return JSON.stringify(matrix);
            }
        }


    </script>
</body>
</html>
